\" target.ref - Wind River SBCP5020/P3041 target specific documentation
\"
\" Copyright (c) 2012 Wind River Systems, Inc.
\"
\" The right to copy, distribute, modify or otherwise make use
\" of this software may be licensed only pursuant to the terms
\" of an applicable Wind River license agreement.
\"
\" modification history
\" --------------------
\" 01h,25jun12,y_y  add INCLUDE_DOSFS_CACHE macro. (WIND00356868)
\" 01g,14may12,y_y  updated documentation for SBC P3041 board.
\" 01f,27apr12,y_y  added SATA support.
\" 01e,09apr12,h_k  removed SYSTEM_GLOBALS and RESERVED_ATOMICS. (WIND00341977)
\" 01d,27mar12,y_y  added LED support.
\" 01c,06mar12,y_y  add vxbus I2C support.
\" 01b,27feb12,x_z  replaced legacy driver with vxBus driver for NOR-Flash;
                    added new Flash NVRAM interface.
\" 01a,21jan12,y_y  Created from wrSbcP4080 target.ref 01t
\"
\"
\TITLE wrSbcP5020/wrSbcP3041 - Wind River SBCP5020/P3041

\sh NAME
`Wind River SBCP5020/SBCP3041'

INTRODUCTION

This reference entry provides board-specific information necessary to run
VxWorks for the wrSbcP5020/wrSbcP3041 BSP.

The Wind River SBCP5020/P3041 board is a 2/4-core processor based on the 
e5500 architecture. The e5500 is a 32-bit architecture with 36-bit physical 
address space. The P5020/P3041 is designed as a high-speed network processing 
platform with both 10/100/1000Mbps and 10 gigabit ethernet controllers and 
various network offload features, collectively known as the Data Path 
Acceleration Architecture (DPAA).

The P5020/P3041 includes the following built-in hardware components:

    . Two/Four e5500 cores capable of clock speeds up to 1.5Ghz
    . One integrated PCI Express controllers
    . Four I2C controllers
    . Two DDR3 memory controllers
    . Two USB 2.0 controllers
    . Two UARTs
    . Hardware queue manager message passing framework (Qman)
    . Hardware buffer manager (Bman)
    . Two frame managers (Fman)
    . Five 10/100/1000 DTSEC ethernet MACs
    . One 10 gigabit TGEC ethernet MACs
    . Security Engine (SEC 4.0)
    . Pattern Matching Engine (PME 2.1)
    
The P5020/P3041 can be configured to support different peripheral combinations 
via it reset configuration word (RCW), which can be stored in I2C EEPROM.

The Wind River SBCP5020/P3041 incorporates the P5020/P3041 processor, along with 
4GB of DDR3 RAM, NOR and NAND flash, I2C and parallel EEPROMs, a 2x16 character 
debug LCD display, debug LEDs, and a JTAG port for use with the Wind River
ICE II emulator or probe.

The SBCP5020/P3041 board is configured to support the following I/O interfaces:

    . one x4 PCIe slots
    . two UARTs
    . one USB host port
    . one USB target port
    . two RGMII 10/100/1000 DTSEC ethernet ports
    . four SGMII 10/100/1000 DTSEC ethernet ports
    . one XAUI 10 gigabit TGEC port 

The SBCP5020/P3041 uses two I2C EEPROMs for storing the RCW, which can be selected
using a jumper JP18. Each RCW provides a different hardware I/O configuration, 
which are defined as follows:

    Configuration 1:
    ---------------
    
    . two SATA ports
    . two RGMII 10/100/1000 ethernet ports(DTSEC3/DTSEC4)
    . one XAUI 10 gigabit ethernet port
    . one x4 PCIe slots
    
    Configuration 2:
    ---------------
    
    . two SATA ports
    . four SGMII 10/100/1000 ethernet ports (via SFP modules DTSEC0-3)
    . one XAUI 10 gigabit ethernet port
    . one x4 PCIe slots

The four SGMII ethernet ports are wired to SFP slots, which must be populated
with 1000baseT copper SFP modules for full functionality. The XAUI 10 gigabit
ethernet port requires a fiber XFP module for full functionality. The 
SBCP5020/SBCP3041 evaluation kit includes only one Methode Electronics DM7041 
1000baseT copper SFP module: additional SFP modules and the XFP module may be 
purchased separately. (A Finisar FTLX8511D3 or similar XFP module is recommended.)

\sh Switches

There are two switches at the bottom corner of the wrSbcP5020/wrSbcP3041 board.

Default Switch Settings for SBCP5020:

\ts
Switch Number   | Switch ON      | Switch OFF
------------------------------------------
SW1             | 2,4,6,8        | 1,3,5,7
SW2             | 1,2,3,4,6,7    | 5, 8
\te

Default Switch Settings for SBCP3041:

\ts
Switch Number   | Switch ON      | Switch OFF
------------------------------------------
SW1             | 2,4,6,8        | 1,3,5,7
SW2             | 1,2,3,4,6,7,8  | 5
\te

\sh Jumpers

There are thirteen jumpers in the wrSbcP5020/wrSbcP3041 board.

Default jumper Settings:

\ts
Switch Number   | Description                      | Setting
--------------------------------------------------------------
JP2             | Enable system flash WP           | Open
JP4             | Flash Write Protect for Primary  | Open
JP5             | Flash Write Protect for Alternate| Open
JP6             | Flash Select                     | Position 1-2
JP10            | XAUI Clock Select                | Position 1-2
JP11            | PCIe/SFP Clock Select            | Position 2-3
JP12            | SATA Clock Select                | Position 2-3
JP13            | LAB VDD Override                 | Open
JP14            | TRST Select                      | Open
J17             | System Clock Select              | Position 1-2
JP18            | Reset Configuration Word Select  | Install
JP19            | POVDD Fuse Read                  | Position 1-2
J21             | Input Power Selection            | Position 2-3

\te

The switch and jumper settings are described in detail in the SBCP5020/P3041
Hardware Reference Manual included with the evaluation kit.

\sh Getting the board running VxWorks (boot from VxWorks Bootrom)
This section will guide you on how to run VxWorks on the
wrSbcP5020/wrSbcP3041 board.

1. Creating a bootrom.bin:

    Open the VxWorks Development Shell, change directory to wrSbcP5020
    BSP directory, and then build the VxWorks bootrom image.

\cs
    cd target/config/wrSbcP5020
    make bootrom.bin
or
    cd target/config/wrSbcP3041
    make bootrom.bin
\ce

2. Flashing the VxWorks bootrom with Workbench

    Using Workbench, complete the following steps to flash your boot ROM image:
    Notes: Support for wrSbcP5020/wrSbcP3041 target is available with Workbench 3.3.

    2.1 Install Wind River Probe or Wind River ICE and power it on.

        Connect the JTAG interface cable from the Wind River Probe or Wind
        River ICE to the wrSbcP5020/wrSbcP3041 board's JTAG connector (P1).
        Once the connections have been made, power up the target board and
        launch Workbench on the host.

    2.2 Configure the Wind River Probe or Wind River ICE connection.

        In Workbench on the left pane, there is a "Remote Systems" window.
        Click on the "Define a connection to remote system" button. In the popup
        "New Connection" window, select the Connection type as
        "Wind River OCD ICE Connection" for Wind River ICE and "Wind River
        OCD Probe Connection" for Wind River Probe. If the Wind River ICE
        is connected via serial port, specify the configuration else select
        "Specify all communication settings manually".

        In the "Wind River ICE Settings" or "Wind River Probe Settings",
        select the Board file by clicking on the "Processor" radio button and
        browse to the appropriate CPU type. For example: "P5020E/P3041E".
        Connect Workbench OCD with the Wind River Probe or Wind River ICE
        by clicking the "Next" and then "Finish" button. A New connection
        appears in the "Remote Systems" window.

    2.3 Program Wind River Probe / Wind River ICE with the proper register
        settings for the wrSbcP5020/wrSbcP3041 board.

        To view/modify the Wind River ICE firmware setting, terminate the
        debug session for Wind River ICE. In the "Remote Systems" window,
        right click on the newly connected OCD connection. Select
        "OCD Utilities". To know about the current firmware information,
        select "Emulator firmware version information". To download the new
        firmware, Select "Firmware Download" and select appropriate file
        from "$WIND_OCD_PATH/CommonHardwareFiles/*.bin".

        Go to the "OCD Command Shell" and click on the "Settings" button.
        The OCD Command Shell Settings dialog appears, where you can
        select the appropriate register file, which is "WRS_SBCP5020_PCTR0360001_VxWorks.reg".
        for SBCP5020 or "WRS_SBCP3041E_PCTR0364002.reg" for SBCP3041.
        After choosing the register file, press the "OK" button. In the OCD
        Command Shell, click the "Playback File" button. The selected register
        file is downloaded to the target and the commands from the file appear
        in the OCD command shell. When playback is finished the ">BKM>" or
        the ">ERR>" prompt returns.

    2.4 Get into Background Mode.

        Execute the "IN" command to reset the board and initialize it with
        the register setting.
\cs
        IN
\ce

    2.5 Program the wrSbcP5020/wrSbcP3041 Flash.

        In WindRiver OCD, Select the "Flash Programmer". The "Flash Programmer"
        view has three tabs: "Configuration", "Programming" and "Memory/Diagnostics".

        2.5.1 Select the "Configuration" tab. In the "Device Selection'
              field, select the "Intel -> 28F128P30T -> 8192 x 16 -> 1 Device"

              In "Flash Bank Address" group for the "Base" enter "FF000000" .
              In the "RAM Workspace" group for the "Workspace Start at"
              enter "0x00000000" and for the "Workspace Size" enter "65000".

        2.5.2 Click on the "Programming" tab. Select the "Add File" button, in
              the popup window, select the newly generated
              "$(WIND_BASE)/target/config/wrSbcP5020/bootrom.bin" or 
              "$(WIND_BASE)/target/config/wrSbcP3041/bootrom.bin", and click
              the "This is a raw binary file" checkbox then click "OK" to finish
              file adding. Click the "Start Address" and set it as "0xfff00000",
              the "End Address" will be fixed automatically. Please notice that
              the "Start Address" should include the "Offset bias".
              Enable a file by clicking on the checkbox under the "Enabled" heading.

        2.5.3 Press the "Auto Program" button to erase the flash and then program
              the flash with selected "bootrom.bin" file. A window pops up to show
              the progress of the Flash device programming. When it is complete,
              the Flash should contain the new boot program.

3. Running the VxWorks bootrom

   Re-power on the board, the VxWorks bootrom should come up.

Note: once a new bootrom has been flashed, check to make sure that MAC
addresses for the DTSEC and TGEC ethernet ports have been set by using the
'M' command at the '[VxWorks Boot]:' prompt. The MAC addresses and the
bootline are stored in EEPROM, and should match those printed on the
sticker affixed to the board. If the MAC address fields are uninitialized
and contain nonsense or illegal values, network connecvitity may be impaired.

FEATURES

This section describes all features of the board, supported or not.
It documents all configurations of the board and the interaction between
features and configuration items.

\sh List of Hardware Features (wrSbcP5020/wrSbcP3041 board)

\ts
Hardware Interface | Controller | Driver/Component    | Status
--------------------------------------------------------------
UART:0             | on-chip    | vxbNs16550Sio.c     | SUPPORTED
UART:1             | on-chip    | vxbNs16550Sio.c     | SUPPORTED
1GB-ETHERNET:0     | on-chip    | vxbDtsecEnd.c       | SUPPORTED
1GB-ETHERNET:1     | on-chip    | vxbDtsecEnd.c       | SUPPORTED
1GB-ETHERNET:2     | on-chip    | vxbDtsecEnd.c       | SUPPORTED
1GB-ETHERNET:3     | on-chip    | vxbDtsecEnd.c       | SUPPORTED
1GB-ETHERNET:4     | on-chip    | vxbDtsecEnd.c       | SUPPORTED
10GB-ETHERNET:0    | on-chip    | vxbTgecEnd.c        | SUPPORTED
NOR-FLASH:0        | 28F128P30  | vxbNorFlash.c       | SUPPORTED
NOR-FLASH:1        | 28F128P30  | vxbNorFlash.c       | SUPPORTED
TIMER              | on-chip    | vxbM85xxTimer.c     | SUPPORTED
TIMER              | on-chip    | vxbOpenPicTimer.c   | SUPPORTED
PCI-E-HOST:0       | on-chip    | vxbQorIQPciEx.c     | SUPPORTED
DMA:0              | on-chip    | vxbFslDma.c         | SUPPORTED
DMA:1              | on-chip    | vxbFslDma.c         | SUPPORTED
I2C:0              | on-chip    | vxbFslI2c.c         | SUPPORTED
I2C:1              | on-chip    | vxbFslI2c.c         | SUPPORTED
I2C:2              | on-chip    | vxbFslI2c.c         | SUPPORTED
I2C:3              | on-chip    | vxbFslI2c.c         | SUPPORTED
I2C-EEPROM         | on-chip    | vxbI2cEeprom.c      | SUPPORTED
USB-HOST:0         | on-chip    | INCLUDE_USB         | SUPPORTED
USB-TARGET:0       | on-chip    | INCLUDE_FSL_TCD     | SUPPORTED
GPIO               | on-chip    | vxbFslGpio.c        | SUPPORTED
LCD                | CPLD       | sysLcd.c            | SUPPORTED  
LED                | CPLD       | sysLed.c            | SUPPORTED
EEPROM             | on-chip    | eeprom.c            | SUPPORTED
SATA               | on-chip    | DRV_STORAGE_FSLSATA | SUPPORTED
eSATA              | on-chip    | DRV_STORAGE_FSLSATA | SUPPORTED
NAND-FLASH         | NAN01GW3B2C| -                   | UNSUPPORTED
SRIO               | on-chip    | -                   | UNSUPPORTED
Security Engine    | on-chip    | -                   | UNVALIDATED
Performance Monitor| on-chip    | -                   | UNSUPPORTED
\te

\sh Feature Interactions
Refer to the board vendor's documentation.

HARDWARE DETAILS

This section documents the details of the device drivers and board
hardware elements.

\sh Verified Hardware
This BSP has been verified on PCA-R0364-001 REV.B of wrSbcP5020 board and
PCA-R0364-001 REV.B of wrSbcP3041 board.
The default clock speed for wrSbcP5020 is 1600MHz for core0-1, 600MHz for CCB.
The default clock speed for wrSbcP3041 is 1200MHz for core0-3, 600MHz for CCB.
The default system clock is 100Mhz(J17 1-2), 133Mhz also supported in this 
release. (OSCILLATOR_FREQ need updated When 133Mhz used)

\sh Memory Maps
The default hardware memory map of this BSP is as follows:

\ts
Start       | Size  | End         | Access to
---------------------------------------------
0x0000_0000 |  2GB  | 0x7FFF_FFFF | DDR3 SDRAM
0x8000_0000 |  64MB | 0x83FF_FFFF | PCIe 1 Prefetchable Memory
0x8400_0000 |  64MB | 0x87FF_FFFF | PCIe 1 Non-Prefetchable Memory
0x8800_0000 |  64MB | 0x8BFF_FFFF | PCIe 1 IO
0x8C00_0000 |  64MB | 0x8FFF_FFFF | PCIe 1 IO32
0xF000_0000 |  16KB | 0xF000_3FFF | EEPROM
0xF100_0000 |  64KB | 0xF100_FFFF | LCD
0xF200_0000 |  16MB | 0xF2FF_FFFF | USER FLASH
0xF400_0000 |   2MB | 0xF41F_FFFF | QMAN
0xF420_0000 |   2MB | 0xF43F_FFFF | BMAN
0xFE00_0000 |  16MB | 0xFEFF_FFFF | CCSR
0xFF00_0000 |  16MB | 0xFFFF_FFFF | NOR FLASH
\te

The default software memory map of the wrSbcP5020 is as follows:

\ts
Start       | End         | Used for
---------------------------------------------
0x0000_0100 | 0x0000_3500 | Vectors (3500 - Performance Mon)
0x0000_4100 | 0x0000_41FF | SM_ANCHOR
0x0000_4200 | 0x0000_42FF | BOOT_LINE
0x0000_4300 | 0x0000_43FF | EXC_MSG
0x0001_0000 | 0x0007_FFFF | SM_MEM_ADRS
0x0008_0000 | 0x000C_0000 | SM_OBJ_MEM_ADR
0x000C_0000 | 0x000D_FFFF | SM_TIPC_ADRS_DEFAULT
0x000F_0000 | 0x000F_0014 | CPUn_SPACE(1)
0x000F_0000 | 0x000F_FFFF | root stack (core 0)
0x0010_0000 | 0x4000_0000 | core 0 image and heap space
0x4000_0000 | 0x400F_FFFF | root stack (core 1)
0x4001_0000 | 0x4200_0000 | core 1 image and heap space
0x4000_0000 | 0x4100_0000 | VIRTUAL_SM_BASE_PHYS
0x4001_0000 | 0x4009_0000 | MIPC_SM_SYSTEM_POOL_BASE_PHYS
0x7700_4400 | 0x7700_44FF | TM_ANCHOR_ADRS
0x7800_0000 | 0x78FF_FFFF | VIRTUAL_SM_BASE
0xFFFF_FFFC |             | Reset vector
\te

The default software memory map of the wrSbcP3041 is as follows:

\ts
Start Addr  | End Addr    | Used for
---------------------------------------------
0x0000_0000 | 0x000F_FFFF | PHYS_MEM_START
0x0000_0000 | 0x3FFF_FFFF | (core 0) LOCAL_MEM_LOCAL_ADRS
0x0000_0100 | 0x0000_3500 | Vectors (3500 - Performance Mon)
0x0000_4100 | 0x0000_41FF | SM_ANCHOR
0x0000_4200 | 0x0000_42FF | BOOT_LINE
0x0000_4300 | 0x0000_43FF | EXC_MSG
0x0010_0000 | 0x1FFF_FFFF | core 0 image/heap
0x4000_0000 | 0x4FFF_FFFF |(core 1 dynamic) LOCAL_MEM_LOCAL_ADRS
0x4010_0000 | 0x4FFF_FFFF | core 1 image/heap (RAM_LOW_ADRS)
0x5000_0000 | 0x5FFF_FFFF |(core 2 dynamic) LOCAL_MEM_LOCAL_ADRS
0x5010_0000 | 0x5FFF_FFFF | core 2 image/heap (RAM_LOW_ADRS)
0x6000_0000 | 0x7FFF_FFFF |(core 3 dynamic) LOCAL_MEM_LOCAL_ADRS
0x6010_0000 | 0x76FF_FFFF | core 3 image/heap (RAM_LOW_ADRS)
0x6001_0000 | 0x6008_FFFF | MIPC_SM_SYSTEM_POOL_BASE
0x4000_0000 | 0x400F_FFFF | root stack (core 1)
0x5000_0000 | 0x500F_FFFF | root stack (core 2)
0x6000_0000 | 0x600F_FFFF | root stack (core 3)
0x7700_4400 | 0x7700_44FF | TM_ANCHOR_ADRS
0x7800_0000 | 0x78FF_FFFF | VIRTUAL_SM_BASE
0xFFFF_FFFC |             | Reset vector
\te

Note: As shown above, some software areas may overlap based on kernel
component configuration.

\sh Serial Configuration
No special configuration needed.
Default configuration is:
    Baud Rate: 9600
    Data: 8 bit
    Parity: None
    Stop: 1 bit
    Flow Control: None

\sh Network Configuration
The DTSEC ports allow 10/100/1000 connections. The driver will auto-negotiate
and configure the port accordingly.  The BSP also supports TGEC with a 10G 
connection; however, the TGEC driver has not been validated with this BSP.

The following END drivers are supported in this BSP.

\ts
Driver | END                    
--------------------------
DTSEC  | DRV_VXBEND_DTSEC       
TGEC   | DRV_VXBEND_TGEC
\te

The P5020/P3041 processor has a total of 6 internal network controllers, spread
across one frame managers. However, not all ports can be enabled simultaneously.
Note that the TGEC MAC can only operate at 10 gigabit speeds, so while it may 
be possible to use multi-speed media modules, only 10G links will work.

Various port configurations can be selected by modifying the reset
configuration word (RCW). The SBCP5020/SBCP3041 board comes programmed with two 
operational RCW's. They are stored in seperate on-board I2C EEPROMs. The EEPROMs 
are selectable with JP18. The factory default is to have JP18 installed. 
Removing JP18 selects the alternate RCW.

With JP18 installed, dtsec3 and dtsec4 are enabled(default). This corresponds to 
the DTSEC port on the frame manager operating in RGMII mode.  When JP18 is removed, 
using the dtsec0, dtsec1, dtsec2, dtsec3 ports requires the DRV_MII_I2C_MDIO 
driver component. And dtsec3 also need set DTSEC3_IN_RGMII macrom to FALSE in 
config.h. This corresponds to the four DTSEC ports on the frame manager operating in 
SGMII mode, and the dtsec4 port still operating in RGMII mode.

When JP18 removed, the dtsec0, dtsec1, dtsec2 and dtsec3 interfaces are wired to 
the four SFP ports on the front of the board. The SBCP5020/P3041 kit comes with
one port (dtsec0) populated with a Methode Eletronics DM7041 1000baseT copper 
SFP module. Additional SFP modules can be purchased separately to populate the 
remaining 3 ports. Note that even if an SFP port is not populated, a "dtsec" 
device driver instance is still created by vxWorks. However, lacking a PHY, 
the device consequently will not function.

The the following diagrams illustrate the two port configurations, and how
the board should be configured to support them:

\cs
   SRDS_PRTCL 0x22 setup (JP18 installed)

   ------------- 
   |Fman1  MAC4| -- dtsec3
   |RGMII  MAC5| -- dtsec4
   |       PCIE| 
   |      SATA1| 
   |      SATA2| 
   |    10G MAC| 
   ------------- 

   SRDS_PRTCL 0x34 setup (JP18 removed)

   -------------               
   |Fman1  MAC1| -- dtsec0     
   |SGMII  MAC2| -- dtsec1     
   |       MAC3| -- dtsec2     
   |       MAC4| -- dtsec3     
   |       PCIE| 
   |      SATA1| 
   |      SATA2| 
   |    10G MAC|               
   -------------               

\ce

Using the DTSEC ports requires the DRV_VXBEND_DTSEC driver component. Using
the 10 gigabit TGEC port requires the DRV_VXBEND_TGEC driver component. When
JP18 is removed and the SGMII ports are enabled the DRV_MII_I2C_MDIO driver 
components are also required in order to provide link management support for 
the SFP PHYs. Many 1000baseT copper SFP modules from various vendors use the 
Marvell 88E1111 PHY driver internally. The INCLUDE_MV88E1X11PHY driver 
component is used to manage this PHY chip.

Both the DTSEC and TGEC drivers include support for jumbo frames.

For SPF mode, only the Methode Eletronics DM7041 1000baseT cppper SPF module is validated.

\sh Ethernet Address
Six Ethernet hardware addresses are assigned to wrSbcP5020/wrSbcP3041 board.
A unique address is absolutely necessary if the user wishes to
connect the board to a network.  Thus, the user must provide a suitable
6-byte Ethernet address for each on-board network interface.

Definition of the macro ETHERNET_MAC_HANDLER in wrSbcP5020.h indicates the MAC
address is stored in NVRAM and alterable via the 'M' bootrom command.  This
option allows only the last three bytes to be changed. To use this option,
open a console window and reset the hardware. When the bootrom banner appears
and the countdown starts, press any key to get the "[VxWorks Boot]:" prompt.
Type the 'M' command to modify the MAC address.

\sh DPAA Support

In addition to standard DTSEC and TGEC END drivers, support is also
provided for Qman, Bman and Fman DPAA components. The vxbQorIQQman,
vxbQorIQBman and vxbQorIQFman modules support the following functionality:

\is
\i User creation of Qman frame queues
\i Interrupt driven and polled Qman event handling
\i Management of Bman buffer pools
\i Use of Fman hard parser for RX checksum offload in the DTSEC and TGEC drivers
\i APIs provided to program the keygen, parser, coarse classifier and policer in the Fman
\ie

Documentation for these APIs can be found in the following files:

\is
\i target/src/hwif/resource/vxbQorIQBmanPortal.c -- Bman API
\i target/src/hwif/resource/vxbQorIQQmanPortal.c -- Qman API
\i target/src/hwif/resource/vxbQorIQQmanFman.c -- Fman API
\ie

\sh Boot Devices
The supported boot devices are:

\ts
    `dtsec0-4'  | DTSEC0-4
    `fs'        | USB/TFFS/SATA
\te

\sh Boot process and VxWorks images

Previous releases of VxWorks BSPs provided separate BSP directories for AMP images.
As of the vxWorks 6.9 release UP, SMP, AMP, and bootrom images are now generated from
a single BSP directory.

\sh SMP

VxWorks SMP(Symmetric Multiprocessing) kernels can be configured for use on
the multiprocessor target hardware supported by this BSP. Please refer to
the chapter "VxWorks SMP" of vxworks_kernel_programmers_guide_6.9.pdf for 
details about the SMP-specific features in the operating system.

For convenience, some key features for using SMP with this BSP are highlighted
below.

1. SMP build

   VxWorks SMP can be configured and built using the standard Wind River
   Workbench and vxprj facilities. However, VxWorks SMP images cannot be 
   created from the legacy BSP-directory configuration and build methods 
   (using config.h and the local Makefile).

   Workbench provides a VxWorks Image Project (VIP) option for creating VxWorks
   SMP projects. vxprj uses the '-smp' option to specify configuration of
   VxWorks SMP from the command line. For example:

\cs   
   vxprj create -smp wrSbcP5020/wrSbcP3041 diab prj
   vxprj build prj/prj.wpj
\ce

2. Boot loader

   The 'bootrom' images for VxWorks cannot be built with the SMP configuration
   option. As such, the 'bootrom' image may still be built using the legacy
   BSP directory and Makefile method. With Workbench, build the 'bootrom' using
   the same steps as for a UP system,

   Finally, while the 'bootrom' itself cannot be configured for SMP, it will
   support loading UP, SMP and AMP enabled images.

3. MMU

   VxWorks SMP does not support MMU-less configuration.
   
4. Cache and bus snoop

   Snoop logic is specific to the hardware architecture. Usually it is supported
   by multiprocessor hardware. When hardware support is present, CACHE_SNOOP_ENABLE
   should be specified in the BSP to maintain system coherency. Please refer to 
   the config.h of this BSP to find how CACHE_SNOOP_ENABLE is used.

   Note: CACHE_SNOOP_ENABLE is required for PowerPC, ARM and IA. It is undefined
   for MIPS BSPs.

   Cache cannot be disabled in a VxWorks SMP system. Direct calls to the 
   function cacheDisable() will do nothing.
   
   Also, only copy-back mode is tested and supported for VxWorks SMP kernels. This
   will be the default configuration set by BSP. Changing the cache mode
   to write-through may result in unpredictable behavior. Some architectures
   place additional restrictions on write-through mode. For example, write-through
   is not allowed at all by VxWorks for PowerPC processors because the atomic 
   instructions stwcx and lwarx are used by the kernel and would generate 
   machine check exceptions if the cache is in write-through mode. Similarly,
   ARM does not allow write-through with SMP.

5. Interrupt CPU affinity 

   Hardware resources can be allocated via VxWorks configuration. Here we focus on the 
   interrupt to show how it's implemented. SMP hardware usually requires programmable 
   interrupt controller. VxWorks SMP makes use of this hardware to allow assignment 
   interrupts to a specific CPU. By default, interrupts are routed to the VxWorks 
   instance's logical CPU 0. Interrupt CPU affinity can be useful for load balancing, 
   
   For example, in hwconf.c of this BSP, there is the following data structure:
   
   struct intrCtlrCpu epicCpu[] = { { EPIC_XX_INT_VEC, 0 },};
   
   User can reroute the interface interrupt to other CPUs by changing 
   0 to 1 or any other supported CPU index.
   
6. CPU number

   The project parameter VX_SMP_NUM_CPUS is used to specify the number of CPUs
   assigned to the SMP kernel. The CPU number we are discussing here includes all the 
   hardware units which have the same behavior as CPU, for example, the thread, 
   hyper-thread, etc. VxWorks supports less than all of the CPUs in a multiprocessor system 
   to participate in the SMP kernel. This allows some CPUs to be used for other purposes 
   such as dedicated "bare-iron" tasks or additional asymmetric operating systems. CPUs not 
   assigned to the SMP kernel are left in the default, power-on reset state. 

   The maximum CPU number for this BSP is 2 or 4. Note, the maximum possible value 
   for vxWorks is 32.

\sh VxWorks AMP with wrload and MIPC

AMP enabled kernels must be built from Workbench or vxprj. Any of the
AMP image can be built based on the wrSbcP5020/wrSbcP3041 BSP, however each
image must be configured manually with the appropriate components for
the core on which it is to execute.

For instance, core 0 must be configured with the components to execute
as the primary CPU. To assist with component configuration, the bundle
BUNDLE_AMP_PRI will automatically add the components required for the 
kernel on core 0.

\cs
$ cd $WIND_BASE/target/config/wrSbcP5020
$ vxprj create wrSbcP5020 or wrSbcP3041 diab amp0
& vxprj component add amp0/amp0.wpj INCLUDE_AMP INCLUDE_AMP_CPU_00 INCLUDE_WRLOAD INCLUDE_SHELL
& vxprj build amp0/amp0.wpj
\ce                            

The images for core 1 must be configured with the components to
execute as a secondary CPU. Again, a bundle has been created to assist
with addition of the required components. Use vxprj to add the 
appropriate component, INCLUDE_AMP_CPU_01. Also, vxprj automatically
maintains mutual exclusion among the CPU components. Adding a CPU 
component removes the pre-existing one.

\cs
$ cd $WIND_BASE/target/proj
$ vxprj create wrSbcP5020/wrSbcP3041 diab amp1
& vxprj component add amp1/amp1.wpj INCLUDE_AMP INCLUDE_AMP_CPU_01 INCLUDE_WRLOAD_IMAGE_BUILD 
& vxprj component add amp1/amp1.wpj INCLUDE_SHELL
& vxprj build amp1/amp1.wpj
\ce                             

The images for core 2:

\cs
$ cd $WIND_BASE/target/proj
$ vxprj create wrSbcP3041 diab amp2
& vxprj component add amp2/amp2.wpj INCLUDE_AMP INCLUDE_AMP_CPU_02 INCLUDE_WRLOAD_IMAGE_BUILD 
& vxprj component add amp2/amp2.wpj INCLUDE_SHELL
& vxprj build amp2/amp2.wpj
\ce

The images for core 3:

\cs
$ cd $WIND_BASE/target/proj
$ vxprj create wrSbcP3041 diab amp3
& vxprj component add amp3/amp3.wpj INCLUDE_AMP INCLUDE_AMP_CPU_03 INCLUDE_WRLOAD_IMAGE_BUILD 
& vxprj component add amp3/amp3.wpj INCLUDE_SHELL
& vxprj build amp1/amp1.wpj
\ce  

The following configurations are provided as optional:

\ts
Image Type    | Components
------------------------------
AMP           | INCLUDE_MSD INCLUDE_SHELL INCLUDE_MIPC_SM INCLUDE_MIPC_SHOW
\te

Of course, Workbench may be used instead of vxprj.  Navigate the 
configuration menus thusly:
Kernel configurations: hardware -> BSP configuration variants -> VxWorks AMP core build

Boot using an image created from wrSbcP5020/wrSbcP3041 BSP using vxprj or
Workbench; the default bootrom provided from the wrSbcP5020/wrSbcP3014 BSP may
be used to boot this image.

Call wrload using the following either add as part of the usrAppInit or call
from a shell such as the target shell.

For Example: (assign dtsec0 to CPU1)

\cs
-> wrload "-f <image_dir>/vxWorks -c 1 -tsym \"*sysBootLine= dtsec(0,1) 
   h=<host_IP_address> e=<ethernet_IP_address> u=target pw=vxTarget f=0\" "
\ce

   MIPC is the fundamental technology for wrload implementation. Please see 
   MIPC-related description in this document for more details.

\sh wrload and memory management. 

wrload, executed from the primary CPU, calls the function usrWrloadMap() to
dynamically allocate virtual memory pages in the primary CPU's context for
placing the secondary image into physical memory.  The argument to
usrWrloadMap() is 'pAddr' which is set based upon the ELF file's load memory
address (LMA) plus a physical bias.

The physical bias is compiled into the loaded image via the CDF parameter 
WRLOAD_IMAGE_BUILD_PHYS_BIAS.  The value of the parameter is stored across two
32 bit variables as (_wrload_bias_high_32 | _wrload_bias_low_32). wrload, on 
the primary CPU, reads these symbols directly from the ELF file prior to 
loading.  This physical bias is superseded by wrload's -loadbias argument
(i.e. a dynamic bias not defined at build time).  Which ever value is used, 
the result is placed into the symbol _wrload_bias.

There are a few limitations when using WRLOAD_IMAGE_BUILD_PHYS_BIAS.
If the -loadbias argument is used, the primary CPU will load the image to the
physical bias specified by -loadbias, however the secondary CPU cannot execute
the image because the sysPhysMemDesc table and sysVirtToPhys routines use the
WRLOAD_IMAGE_BUILD_PHYS_BIAS macro defined at compile-time.  If a load bias is
used, the MMU no longer uses a 1-to-1 physical-to-virtual mapping.  The ICE
may require a 1-to-1 mapping (with a physical bias of 0) to properly debug
an image.  Finally, the bootrom supports but constraints the bias to lie on
a 256MB boundary.

For secondary images the bootrom (romInit) reads a shared memory area
starting at CPUn_SPACE to get the image's stack pointer, starting address
and MMU data.  The primary image sets up CPUn_SPACE from sysAmpCpuEnable().
The usrWrload functions usrWrloadBiasHighGet() and usrWrloadBiasLowGet()
are provided for sysAmpCpuEnable() to get the _wrload_bias value and put it
into CPUn_LOCAL_MEM_ERPN and CPUn_LOCAL_MEM_RPN.  The bootrom uses RPN and
ERPN to specify the (36-bit) physical address for a 256MB mapping that the
secondary image starts running in.  The corresponding virtual address is
derrived from the CPUn_FUNC_START_ADR.  Later, as the image boots and runs
sysHwInit() this initial 256MB mapping is overwritten by sysStaticTlbDesc[].
This allows the entries in sysStaticTlbDesc[] to expand (or reduce) the
image's footprint to any workable size.

The primary image's MMU does not include a mapping for the physical area
used by the secondary image(s).  This protects the secondary image(s)
from the primary.  The primary image uses usrWrloadMap() to map a virtual
scratchpad area created just to load the image.  This area must be outside
the primary's current virtual space and is typically the lower 32-bits of
the image physical address.  However, if these lower 32-bits overlap the
primary's current virtual space an error is returned and wrload will abort.
Consequently, a fixed offset wrloadPriScratchMemOffset based on the CDF
parameter WRLOAD_PRI_SCRATCH_OFFSET is added to the lower 32-bits to generate
the virtual address.

As indicated above, the image virtual address is derrived from the start
address and should be RAM_LOW_ADRS.  The physical address is equal to
the virtual address added to the WRLOAD_IMAGE_BUILD_PHYS_BIAS.  

\sh Virtual Shared Memory
This BSP contains enhanced support for AMP, allowing SMP images to participate
in AMP, and allowing SMP images to be loaded above the 32-bit boundary.  To
accommodate these features, one shared memory component has been added.

1. Virtual Shared Memory
This BSP contains enhanced support for AMP, allowing SMP images to participate
in AMP, and allowing SMP images to be loaded above the 32-bit boundary.  To
accommodate these features, virtual shared memory component has been added.

Virtual Shared Memory - the INCLUDE_VIRTUAL_SM is optional, but it must
be added to any image built for loading above the 32-bit boundary utilizing
SMP or MIPC.  This component sets up a virtual to physical mapping above the
1GB (default) page mapping SDRAM, for MIPC.

There are three configurable parameters for INCLUDE_VIRTUAL_SM: VIRTUAL_SM_BASE,
VIRTUAL_SM_BASE_PHYS, and VIRTUAL_SM_SIZE.  These specify the virtual address,
physical address, and size of the region, respectively.  These default to
0x78000000, 0x78000000, and 0x01000000.  The BSP only supports 16MB for the
size.

Note: MIPC is located in this shared memory region by default.  For this
reason, a new configurable parameter is added for the MIPC SM physical address:
MIPC_SM_SYSTEM_POOL_BASE_PHYS.  When designing a system, this physical address
should be matched with other images in the system (Linux, VxWorks, etc.).

\sh Logical Partition Support
The component INCLUDE_LOGICAL_PARTITION is provided to allow each AMP image
to have its own logical partition ID.  This is required when there is any SMP
running in the system, as VxWorks SMP uses tlbivax to invalidate TLBs and
broadcast the invalidation to each of its CPUs.  By default,
INCLUDE_LOGICAL_PARTITION is included when INCLUDE_AMP is included, and its
configuration parameter, LOGICAL_PARTITION_ID, defaults to a unique value
based upon which INCLUDE_AMP_CPU_0x component is included.
LOGICAL_PARTITION_ID can be a value from 0 to 63.  Note that 0 indicates the
global partition.

\sh Boot Methods

The boot methods are affected by the boot parameters.  If no password is
specified, RSH (remote shell) protocol is used.  If a password is specified,
FTP protocol is used, or, if the flag is set to 0x80, TFTP protocol is used.

\sh PCI Express Support

The P5020/P3041 processor has one PCI Express controllers, which are configured
for x4 mode via the PCIe slot 1 connectors. 

Use of the PCIe slots requires the DRV_PCIBUS_QORIQ_PCIEX driver component.
Adding INCLUDE_PCI_BUS with vxprj or from Workbench will automatically add
that component, as well as INCLUDE_PCI_BUS_AUTOCONF, which is also required.
INCLUDE_PCI_BUS_SHOW component can optionally be included to add PCI show
routines. Any supported vxBus PCI driver should work once the QorIQ
PCI bus controller driver is present. Tests have been done with the
INCLUDE_GEI825XX_VXB_END and INCLUDE_FEI8255X_VXB_END drivers. PCIe to
PCI bridges are also supported, as well as both legacy and MSI interrupts.

The PCIe controllers are supported in root complex mode only.

The Marvell YukonII Gigabit Ethernet adapter is one of the tested PCIe devices
supported in this release. Define INCLUDE_MVYUKONII_VXB_END in config.h to
enable this device.

This BSP defaults to use PCIe legacy interrupts. To enable PCIe MSI interrupts,
define following macro in config.h, or add it to your project using the vxprj
tool or Workbench:

\cs
    #define INCLUDE_INTCTLR_DYNAMIC_LIB
\ce

\sh DMA
The DMA Controller is supported in this release. To enable DMA functionality, 
please define following macro in config.h, or add it to your project using
the vxprj tool or Workbench:

\cs
    #define DRV_DMA_FSL
\ce

Note: The MAX transfer size of every slice on each DMA channel should not
exceed 0x03ff_ffff (64M - 1) bytes.

\sh SATA Support

There are 1 SATA interface and 1 eSATA interface, which are connected to socket 
J14 and J18 on the SBCP5020/SBCP3041 board. To use the SATA interfaces, the 
macro DRV_STORAGE_FSLSATA must be defined in config.h.

When using an SATA disk for the first time, you should format it as a FAT file
system by using
\cs
    dosFsVolFormat ("/ata0:1", 0x20, 0);    /@ FAT32 format @/
\ce
or
\cs
    dosFsVolFormat ("/ata0:1", 0x10, 0);    /@ FAT16 format @/
\ce

Now, you can use VxWorks I/O and file system commands to access the SATA card
device as if it was a disk.  For example, you can copy a vxWorks image from
your host to the SATA disk by using file system copy.

\cs
    copy ("vxWorks", "/ata0:1/vxWorks");
\ce
If you want to use SATA disk as a boot device, you should follow these steps:

For command line mode, make sure DRV_STORAGE_FSLSATA is defined in config.h, re-build
a bootrom from the BSP directory under VxWorks Development Shell, and program
it into the flash chip.  Also make sure you have all the necessary file system
components defined in config.h.

For project mode with PROFILE_BOOTAPP profile under Workbench, you should make
sure to include the following components in the Kernel Configuration Window:

\cs
    DRV_STORAGE_FSLSATA
    INCLUDE_ERF
    INCLUDE_DEVICE_MANAGER
    INCLUDE_FS_EVENT_UTIL
    INCLUDE_FS_MONITOR
    INCLUDE_XBD
    INCLUDE_XBD_BLK_DEV
    INCLUDE_XBD_TRANS
    INCLUDE_DOSFS
    INCLUDE_DOSFS_DIR_FIXED
    INCLUDE_DOSFS_DIR_VFAT
    INCLUDE_DOSFS_FAT
    INCLUDE_DOSFS_FMT
    INCLUDE_DOSFS_MAIN
    INCLUDE_DOSFS_CACHE
    INCLUDE_DISK_UTIL
    INCLUDE_BOOT_FILESYSTEMS
\ce

Then right click the project, select "Build Options\Set Active Build Spec...",
check the "default_romCompress" box, you will see "vxWorks.bin(default_romCompress)"
item is listed in the project, right click it and select "Build Target", this
will generate a default_romCompress.bin in the project directory, program
it into the flash chip as a bootrom.

Below is an example by using /ata0:1 as a boot device:

\cs 
    boot device          : fs
    unit number          : 0
    processor number     : 0
    host name            : host
    file name            : /ata0:1/vxWorks
    inet on ethernet (e) : 192.168.0.3:ffffff00
    host inet (h)        : 192.168.0.2
    gateway inet (g)     : 192.168.0.1
    user (u)             : target
    ftp password (pw)    : vxTarget
    flags (f)            : 0x0
\ce

\sh USB Host
The SBCP5020/P3041 has two USB ports, USB1 is a host-only interface and USB2 is 
a device-only interface. USB Enhanced Host Controller (EHCD) driver has been 
integrated into this BSP. To enable USB host support, please define the following 
macro in config.h, or add it to your project using the vxprj tool or Workbench:

\cs
#define INCLUDE_USB
\ce

USB Mass storage device has been verified on the target.

For more information, please refer to Wind River USB for VxWorks 6 PROGRAMMER'S GUIDE

To use the USB module in device mode, please define INCLUDE_FSL_TCD in config.h

This will add support for Target Controller Driver (TCD) for the
Freescale dual-role USB controller, and the Mass Storage device emulator which
sits on top of the TCD. The Mass Storage emulator will use a RAM disk on target
to emulate a storage disk, and when the device is attached to a USB host, it can
work like a USB flash disk, and user can try to copy data to and from the disk
or perform a disk format operation. Since it is emulation using RAM disk, the
actual storage content will be lost once power is turned off. This is
an example for users to verify that the USB device drivers are
working, and users can refer to the source code as a baseline for new
product development.

If you want to use usb disk as a boot device, you should follow these steps:

For command line mode, make sure INCLUDE_USB is defined in config.h, re-build
a bootrom from the BSP directory under VxWorks Development Shell, and program
it into the flash chip. Also make sure you have all the necessary file system
components defined in config.h.

For project mode with PROFILE_BOOTAPP profile under Workbench, you should make
sure to include the following components in the Kernel Configuration Window:

\cs
    INCLUDE_ERF
    INCLUDE_DEVICE_MANAGER
    INCLUDE_FS_EVENT_UTIL
    INCLUDE_FS_MONITOR
    INCLUDE_XBD
    INCLUDE_XBD_BLK_DEV
    INCLUDE_XBD_TRANS
    INCLUDE_DOSFS
    INCLUDE_DOSFS_DIR_FIXED
    INCLUDE_DOSFS_DIR_VFAT
    INCLUDE_DOSFS_FAT
    INCLUDE_DOSFS_FMT
    INCLUDE_DOSFS_CHKDSK
    INCLUDE_DOSFS_MAIN
    INCLUDE_USB_INIT
    INCLUDE_EHCI
    INCLUDE_EHCI_INIT
    INCLUDE_USB_MS_BULKONLY
    INCLUDE_USB_MS_BULKONLY_INIT
    INCLUDE_USB_MS_CBI
    INCLUDE_USB_MS_CBI_INIT
    INCLUDE_BOOT_USB_FS_LOADER
    INCLUDE_BOOT_EDR_SUPPORT
    INCLUDE_DISK_UTIL
    INCLUDE_BOOT_FILESYSTEMS
\ce

Then right click the project, select "Build Options\Set Active Build Spec...",
check the "default_romCompress" box, you will see "vxWorks.bin(default_romCompress)"
item is listed in the project, right click it and select "Build Target", this
will generate a default_romCompress.bin in the project directory, program
it into the flash chip as a bootrom.

You should now be able to use VxWorks I/O and file system commands to access
the USB device as if it were a disk. For example, you can copy a vxWorks
image from your host to usb disk by using file system 'copy'. Of course, you must
define INCLUDE_DISK_UTIL in config.h first.

\cs
    copy ("vxWorks", "/bd0/vxWorks");
\ce

Below is an example by using usb disk "/bd0" as a boot device:

\cs
    boot device          : fs
    unit number          : 0
    processor number     : 0
    host name            : host
    file name            : /bd0/vxWorks
    inet on ethernet (e) : 192.168.0.3:ffffff00
    host inet (h)        : 192.168.0.2
    gateway inet (g)     : 192.168.0.1
    user (u)             : target
    ftp password (pw)    : vxTarget
    flags (f)            : 0x0
\ce

\sh NOR-Flash support

There are 2 on-board NOR-Flash chips. They are disabled by default. The main
Flash is enabled after INCLUDE_TFFS is defined or INCLUDE_NV_RAM is undefined,
and the system Flash is enabled after INCLUDE_TFFS is defined.

For project mode, you should make sure to include the following components in 
the Kernel Configuration Window:

\cs
    DRV_VXB_NORFLASH
    DRV_VXB_NORFLASH_CMDSET_AMD
    DRV_VXB_NORFLASH_CMDSET_ITL
\ce

Note: The unused command set library can be removed if you want.

For detailed NOR-Flash information, just define INCLUDE_VXBUS_SHOW and type the
following command in the target shell:

\cs 
vxBusShow 10
\ce

\sh TrueFFS (only supported on UP mode)

The standard Wind River TrueFFS product is supported in this release.

This BSP uses the Intel 28F128P30 flash as the TrueFFS media. There are three flash 
chips on the SBCP5020/SBCP3041 board. Primary and alternate flash are select by JP6.

The default flash memory map of this BSP is as follows:

\ts
Start       | Size  | End         | Access to
---------------------------------------------
0xf200_0000 | 16MB  | 0xf2ff_ffff | TFFS  - USER_FLASH
0xff00_0000 | 8MB   | 0xff7f_ffff | TFFS  - Primary or Alternate FLASH
0xffee_0000 | 128KB | 0xffef_ffff | NVRAM if INCLUDE_NV_RAM is undefined
0xfff0_0000 | 1MB   | 0xffff_ffff | BOOTROM
\te

Note: VxWorks bootrom are stored in 0xfff00000~0xffffffff, please don't extend 
the TFFS space before you carefully check the flash memory map, otherwise mis-use
of TFFS may corrupt the bootloader (bootrom) causing a boot-up failure.

To use TrueFFS, define INCLUDE_TFFS in config.h. When using TrueFFS on a new FLASH
for the first time, you should format and configure the FLASH by calling:

\cs
    ->sysTffsFormat (0);
    ->sysTffsFormat (1);
\ce

The above commands take a few minutes to complete. (Do not interrupt the 
board during this time. It may result in damage to the flash.) Properly 
formatted TrueFFS volumes can be mounted using the following commands 
(required each time VxWorks boots): 

\cs
    /@ for primary flash @/
    usrTffsConfig (0, 0, "/tffs0");
    /@ for secondary flash @/
    usrTffsConfig (1, 0, "/tffs1");
\ce

If you are using DOSFS, please use

\cs
    dosfsDiskFormat ("/tffs0");
    dosfsDiskFormat ("/tffs1");
\ce

Note: If you are running these commands in the VxWorks target shell, please use

\cs
    -> sp sysTffsFormat,0
\ce

to format the FLASH as it will take long time to complete.

You should now be able to use vxWorks I/O and file system commands to access
the FLASH device as if it were a disk.  For example, you can copy a vxWorks
image from your host to TFFS by using file system 'copy'.  Of course, you should
define INCLUDE_DISK_UTIL in config.h first.

\cs
    copy ("vxWorks", "/tffs0/vxWorks");
\ce

To show system TrueFFS configuration, please use

\cs
    -> sysTffsShow
\ce

To make "/tffs0" a boot device, complete the following instructions:

For command line mode, make sure INCLUDE_TFFS is defined in config.h, re-build
a bootrom from the BSP directory under VxWorks Development Shell, and program
it into the flash chip.  Also make sure you have all the necessary file system
components defined in config.h.

For project mode with PROFILE_BOOTAPP profile under Workbench, you should make
sure to include the following components in the Kernel Configuration Window:

\cs
    INCLUDE_TFFS
    INCLUDE_TL_FTL
    INCLUDE_TFFS_MOUNT
    INCLUDE_ERF
    INCLUDE_DEVICE_MANAGER
    INCLUDE_FS_EVENT_UTIL
    INCLUDE_FS_MONITOR
    INCLUDE_XBD
    INCLUDE_XBD_BLK_DEV
    INCLUDE_XBD_TRANS
    INCLUDE_DOSFS
    INCLUDE_DOSFS_DIR_FIXED
    INCLUDE_DOSFS_DIR_VFAT
    INCLUDE_DOSFS_FAT
    INCLUDE_DOSFS_FMT
    INCLUDE_DOSFS_MAIN
    INCLUDE_TFFS_MOUNT
    INCLUDE_BOOT_FILESYSTEMS
\ce

Then right click the project, select "Build Options\Set Active Build Spec...",
check the "default_romCompress" box, you will see "vxWorks.bin(default_romCompress)"
item is listed in the project, right click it and select "Build Target", this
will generate a default_romCompress.bin in the project directory, program
it into the flash chip as a bootrom.

Below is an example by using /fs as a boot device:

\cs
    boot device          : fs
    unit number          : 0
    processor number     : 0
    host name            : host
    file name            : /tffs0/vxWorks
    inet on ethernet (e) : 192.168.0.3:ffffff00
    host inet (h)        : 192.168.0.2
    gateway inet (g)     : 192.168.0.1
    user (u)             : user
    ftp password (pw)    : pass
    flags (f)            : 0x0
\ce

\sh Programmable Interrupt Controller

The PIC driver provided by this BSP supports all internal and external 
interrupt sources. The driver can also be configured to route such interrupt 
sources to the critical interrupt pin. However, because critical interrupts 
are routed directly to the interrupt source instead of being manager by the 
PIC with IACK or EOI, the Critical Interrupt Summary registers are used to 
check for the source. The transient values in these registers cause a spurious
vector when indexing into the vector table.

\sh I2C support

The DRV_I2CBUS_FSL driver component is used to provide access to the I2C 
controllers. Use of the I2C bus requires the INCLUDE_I2C_BUS driver component.
The EEPROM (U29/U59/U30)devices are connected to I2C bus 0, The DDR SPD info 
EEPROM are connected to I2C bus 1. While the SFP modules are connected to I2C 
bus 3 (see below for GPIO considerations related to the SFP modules). The 
INCLUDE_EEPROMDRV driver component could be used to config the EEPROM as I/O device.

On I2C bus 0, the following addresses are accessible:

\cs
Address| Device           | Function
-------| -----------------| --------------------------------
0x50   | U29 Atmel 64K-bit| Primary Reset Configuration Word
0x51   | U59 Atmel 64K-bit| Alternate Reset Configuration Word
0x57   | U30 Atmel 2K-bit | System Configuration Data
\ce

Note that when JP18 is installed, U29 responds to address 0x50 and U59
responds to address 0x51. When JP18 is removed, U59 responds to address
0x50 instead, and U29 responds to address 0x51. The P5020/P3041 will use
whichever device is configured for addres 0x50 as the RCW source. Only
the Atmel 64K-bit eeproms are supported for programmng the RCW.

On I2C bus 3, the following addresses are accessible:

\cs
Address| Device            | Function
-------| ------------------| --------------------------------
0x50   | Methode DM7041 SFP| Serial EEPROM contents
0x56   | Methode DM7041 SFP| PHY registers
\ce

Note that all four SFP modules are managed from the same I2C controller.
Because they all respond to the same I2C address, special multiplexing
logic is used to connect only one SFP module to the I2C bus at a time.
This multiplexing is controlled via GPIO pins, as described below.
 
\sh GPIO Support

The SBCP5020/P3041 board uses some of the P5020/P3041 GPIO pins for controlling 
the SFP network modules. Each module has an enable pin that can be controlled
via GPIO. Additionally, because each SFP module uses the same I2C address,
two GPIO pins are used to multiplex the clock and data pins from the four
SFP modules so that they can be controlled from a single I2C controller.
The following table illustrates how the SFP control pins are connected to
the GPIO controller:

\cs
              GPIO[18:19]             Function
              -----------             ----------------
              0 0                     SFP module 0 select
              0 1                     SFP module 1 select
              1 0                     SFP module 2 select
              1 1                     SFP module 3 select

              GPIO[0,4,12,26]          Function
              --------------          ----------------
              1 0 0 0                 SFP module 0 enable
              0 1 0 0                 SFP module 1 enable
              0 0 1 0                 SFP module 2 enable
              0 0 0 1                 SFP module 3 enable
\ce

To enable a given SFP module, the corresponding GPIO pins (0, 4, 12 or 26)
must be configured as an output, and driven low. The GPIO controller is
managed using the DRV_RESOURCE_FSLGPIO driver.

\sh MDIO Support

MDIO management for dtsec4 is performed using the DRV_MII_DTSEC_MDIO driver.
MDIO management for the other ports is managed via the DRV_MII_I2C_MDIO
driver, which provides a shim between the I2C management interface on the
SFP modules and the DRV_VXBEND_DTSEC driver. In other configurations (such
as with the WindRiver SBCP5020/P3041 board), all MDIO management could be performed
using the normal MDIO interface, however a separate management mechanism
for the SFP ports is necessary on the wrSbcP5020/wrSbcP3041 target.

\sh LED Support

The INCLUDE_SYSLED driver component which is defined by default is used to 
provide access to the user LED. The function sysLedSet(UINT8 mask, UINT8 value) 
turns the specified user LED (0-7) to on or off. The LED test routine which 
connected auxiliary clock(openPic) to LED will blink one of the user LEDs once
the component INCLUDE_AUX_CLK is defined.

\sh Make Targets
The make targets are listed as the names of object-format files. Append `.hex'
to each to derive a hex-format file name. Other images not listed here may not
be tested.

\ts
`bootrom'
`bootrom.bin'
`vxWorks' (with `vxWorks.sym')
`vxWorks.st'
\te

\sh BSP Bootloaders and Bootroms

\ts
Bootloader/Bootrom   | status
----------------------------------
bootrom              | SUPPORTED
bootrom_uncmp        | SUPPORTED
bootrom_res          | UNSUPPORTED
vxWorks              | SUPPORTED
vxWorks_rom          | UNSUPPORTED
vxWorks_romCompress  | SUPPORTED
vxWorks_romResident  | UNSUPPORTED
\te

Note: The default size of the vxWorks_rom images are larger than the default 
ROM_SIZE of 1MB, so vxWorks_rom are not supported. However, it can be supported
by adjusted ROM_SIZE and the corresponding addresses in config.h and Makefile 
to fit these image.

\sh BSP Validated Tools

\ts
Tool                         | Connection/Type | Status
-------------------------------------------------------
Workbench Debugger           | ETHERNET/WDB    | SUPPORTED
Workbench System Viewer      | ETHERNET/WDB    | SUPPORTED
Workbench MemScope           | ETHERNET/WDB    | SUPPORTED
Workbench ProfileScope       | ETHERNET/WDB    | SUPPORTED
Workbench StethoScope        | ETHERNET/WDB    | SUPPORTED
Workbench CoverageScope      | ETHERNET/WDB    | SUPPORTED
Workbench Core File Analysis | ETHERNET/WDB    | UNVALIDATED
Workbench Sensor Points      | ETHERNET/WDB    | UNVALIDATED
Workbench OCD Debugger       | JTAG            | SUPPORTED
\te

BOARD LAYOUT

\bs
+------------------------------------------------------------------------------+
|   | LCD  |  | LED  | | SW2  | | SW1  |  |   PCIE X4 SLOT |                   |
|   +------+  +------+ +------+ +------+  +----------------+                   | 
|             +---+ +---+  +----+  +----+                                      |
|             |JP2| |JP4|  |JP5 |  |JP6 |                             +--------|
|             +---+ +---+  +----+  +----+                             | XFP    |
|                                                                     +--------|
|                                                                              |
|                                                           +----+    +--------|
|                                       +-----------+       |JP10|    | SFP    |
| +--+                                  |           |       +----+    | 0 - 3  |
| | D|                                  |   QorIQ   |                 |        |
| | D|                                  |           |     +----+      |        |
| | R|                                  |   P5020E  |     |JP11| +----+--------|
| |  |                                  |   P3041E  |     +----+ |SATA| eSATA  |
| +--+                                  +-----------+            +----+--------|
|                                                       +----+  +------+-------|
| +----+            +--+       +--------+               |JP12|  |DTSEC3| DTSEC4|
| |JP13|            |JP|       |  JTAG  |               +----+  +------+-------|
| +----+            |24|       +--------+                          | USB-target|
|                   +--+                                           +-----------|
|             +---+                +----+     +---+                | USB-host  |
|             |J21|                |JP14|     |J17|                +-----------|
|             +---+                +----+     +---+              +------+------|
|                                                                | UART1| UART2|
| +-----+                        +----+     +----+               +------+------|
| | ATX |                        |JP19|     |JP18|                     +-------|
| +-----+                        +----+     +----+                     | POWER |
+------------------------------------------------------------------------------+
\be

SEE ALSO

\tb QorIQ P5020 Reference Manual 

\tb PowerPC E5500 Core Reference Manual 

\tb Motorola PowerPC Microprocessor Family: The Programming Environments

\tb Wind River SBCP5020 Hardware Reference Manual

\tb Wind River SBCP3041 Hardware Reference Manual
