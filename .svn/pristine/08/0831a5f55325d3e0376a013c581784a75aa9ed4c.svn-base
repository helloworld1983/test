/* sysMpc8540Tmr.c - Mpc8540 Timer Library */

/* Copyright 2005 Motorola, Inc. All Rights Reserved */

/*
modification history
--------------------
01b,18aug05,pjh  Added support for AuxClock.
01a,01aug05,pjh  New file.
*/

/*
DESCRIPTION

Timing functions for Big Easy are provided by four global high resolution 
timers integrated into the MPC8540 plus four additional independent 32-bit 
tick timers in a PLD.
 
The four global 32-bit MPC8540 timers are clocked by the RTC input which 
is driven by a 1 MHz clock, or by the CCB. Refer to the MPC8540 reference 
manual for additional details and/or programming information.

The prescaler register may be changed to allow lower resolution for the four 
32-bit tick timers.  All four 32-bit tick timers use the same prescaler 
register.  By lowering the resolution, the maximum interval for the
tick timers to generate an interrupt is increased from 71.6 minutes, at 1MHz 
to 733.0 minutes, at 97 KHz.  The default, and maximum recommended, value 
for the prescaler register is 0xe7, and the minimum value for the prescaler 
is zero.

One of the 32-bit global timers is used for the VxWorks auxClk, so only 3 
of these timers are available for use.  However, if the auxClk is not
used, all 4 global timers are available to the user.  In config.h, the 
definition MPC8540_AUXCLK_TIMER is used to define which of the timers 
is used to implement the auxClk, and is user-configurable. 

Each of the four 32-bit tick timers has a Control Register, a Compare 
Register, and a Counter Register.

Timer Control Register (Tick Timers) -
Bit 0 is the Timer Enable bit of the appropriate timer.  Writing a value of 
"0" disables the timer, and writing a value of "1" enables the timer.  Bit 1
is the Clear Counter on Compare bit.  Writing a value of "0" causes the counter
to not be reset on compare, while writing a "1" will cause the counter to 
reset to zero when it compares with the compare register.  Bit 2 is the Clear 
Overflow Bits bit.   Writing a "1" to this bit will clear the overflow counter.
Bits 4 through 7 are the Overflow Bits.  These bits are the output of the 
overflow counter.  The overflow counter is incremented each time the tick timer 
sends an interrupt to the local bus interrupter.  Bit 8 is the Enable 
Interrupt Bit.  Writing a "1" to this bit will enable the interrupt, while 
writing a "0" will disable the interrupt.  Bit 9 is the Clear Interrupt bit.
Writing a value of "1" will clear the interrupt.  Bit 10 is the Interrupt
Status Bit.  A value of "1" in this bit indicates that a interrupt has been 
generated by the corresponding timer.  A value of "0" indicates that no 
interrupt has been generated by the corresponding timer.  Bits 11 through 31 
and bit 3 are reserved for future implementation.

Timer Compare Register (Tick Timers) -
The timer counter register value is compared to the compare register.  When
they are equal, the timer interrupt is asserted and the overflow counter is
incremented.  If the clear-on-compare mode is enabled, the counter is also
cleared.  For periodic interrupts, this equation should be used to calculate
the compare register value for a specific period (T):

T(us) = (256 - prescaler) / 25MHz

When programming the timer for periodic interrupts, the counter should be 
cleared to zero by software then enabled.  If the counter does not initially
start at zero, the time to the first interrupt may be longer or shorter than
expected.

Timer Counter Register (Tick Timers) -
When enabled, the timer counter register increments every T(us) based on the
equation specified above.  Software may read or write the counter at any time.
 
The following routines are provided for the tick timers.

STATUS sysTickTmrStart (UINT32 timer, UINT32 useconds, UINT32 mode) 

This routine has three input parameters: the first is the number of the timer,
the second is the amount of time until the timer expiration, T(us) based on the
equation above, and the third is the mode of the timer.  The mode of the timer 
is 0 for periodic interrupts or 1 for a single interrupt.  When the timer is 
in "one-time" interrupt mode the user is required to restart the timer, 
which will also enable the interrupt again. When the timer is in "periodic" 
interrupt mode, the timer will trigger an interrupt every "interval" 
microseconds.

STATUS sysTickTmrDisable (UINT32 timer)

This routine will disable the specified tick timer.  The only way to 
restart the timer is to call sysTickTmrStart() again.

STATUS sysTickTmrConnectRoutine (FUNCPTR, int arg, int timer)
STATUS sysTickTmrDisconnectRoutine (UINT32 timer)

These two routines are provided for connecting and disconnecting user-defined
interrupt handlers to the timer interrupts.  Before connecting a new routine be sure to disconnect the old routine by first calling 
sysMpc8540TmrDisconnectRoutine().

The current (real-time) value of a specified timer can be retrieved using
the following routine:

UINT32 sysTickTmrValueGet (UINT32 timer);

The frequency of the tick timers can be set using the following routine:  

STATUS sysTickTmrFreqSet (UINT32 frequency);

When setting the frequency of the 32-bit tick timers specify the frequency 
in Hz.  The minimum frequency allowed is 97656 Hz, and the maximum 
frequency allowed is 25000000 Hz.  

The frequency of the tick timers, in Hz,  can be retrieved by using the 
following routine:

UINT32 sysTickTmrFreqGet ();

The overflow value of each tick timer is used as a counter for the number 
of interrupts the specified timer has received.  The 4-bit overflow value 
increments every time the specified timer generates an interrupt.  This 
overflow value can be retrieved by using the following routine with the 
timer number as the parameter:

UINT32 sysTickTmrOverflowValGet (UINT32 timer);

The 4-bit overflow value of the specified tick timer can be cleared by using 
the following routine:

STATUS sysTickTmrOverflowClear (UINT32 timer);

The following routines are provided for the four MPC8540 global timers.

STATUS sysMpc8540TmrStart (UINT32 timer, UINT32 useconds)

This routine has two input parameters: the first is the number of the timer, 
and the second is the amount of time until the timer expiration, in 
microseconds.  Once the specified timer is started an interrupt will be
generated every "interval" microseconds until the timer is disabled.

STATUS sysMpc8540TmrDisable (UINT32 timer)

This routine will disable the specified global timer.  The only way to 
restart the timer is to call sysMpc8540TmrStart() again.  Beware, using this
routine for the MPC8540_AUXCLK_TIMER will disable the AuxClock, and could 
result in undesirable results.

STATUS sysMpc8540TmrConnectRoutine (FUNCPTR, int arg, int timer)
STATUS sysMpc8540TmrDisconnectRoutine (UINT32 timer)

These two routines are provided for connecting and disconnecting user-defined
interrupt handlers to the timer interrupts.  Before connecting a new routine be sure to disconnect the old routine by first calling 
sysMpc8540TmrDisconnectRoutine().  Beware, using this routine for the 
MPC8540_AUXCLK_TIMER will disable the AuxClock, and could result in 
undesirable results.

The current (real-time) value of a specified timer can be retrieved using
the following routine:

UINT32 sysMpc8540TmrValueGet (UINT32 timer);

The frequency of the global timers, in Hz, can be retrieved by using the 
following routine:

UINT32 sysMpc8540TmrFreqGet ();

The source of the global timers can be set with the following routine:

STATUS sysMpc8540TmrSrcSet (UINT32 rtc);

The frequency of the global timers can be changed by changing the source 
for the global timers.  The rtc parameter can have a value of 0 or 1.  If 
rtc is 0, the frequency of the timers is based on the CCB clock frequency,
and the value of the clock-ratio.  (see sysMpc8540TmrClockRatioSet)  
If rtc is 1, the frequency of the timers is the same as the RTC, 1 MHz.  
Beware, using this routine may change the behavior of the AuxClock. 

STATUS sysMpc8540TmrClockRatioSet (UINT32 ratioSetting);

If the global timer source is the CCB as explained above, the clock ratio 
value is used to determine the frequency of the global timers.  The clock
ratio value can be in the range of 0 - 3.  A clock ratio value of 0 
means that the timer frequency will be the CCB / 8. A clock ratio of 1
means that the timer frequency will be the CCB / 16. A clock ratio of 2
means that the timer frequency will be the CCB / 32. A clock ratio of 3
means that the timer frequency will be the CCB / 64.
Beware, using this routine may change the behavior of the AuxClock. 

The global timers can be used as cascading timers as specified in the MPC8540
reference manual by using the following routine:

STATUS sysMpc8540TmrCascade (UINT32 cascadeSetting);

The setting for cascading the timers can be in the range 0 - 7, and will 
cause the timers to behave as described below.  Please be aware that the 
MPC8540_AUXCLK_TIMER should not be used as part of a cascaded timer.

0 Default setting.  Timers not cascaded.
1 Cascade timers 0 and 1.
2 Cascade timers 1 and 2.
3 Cascade timers 0, 1, and 2.
4 Cascade timers 2 and 3.
5 Cascade timers 0 and 1; timers 2 and 3.
6 Cascade timers 1, 2, and 3.
7 Cascade timers 0, 1, 2, and 3.

The global timers can be used as cascading timers with rollover characteristics
as specified in the MPC8540 reference manual by using the following routine:

STATUS sysMpc8540TmrRolloverSet (UINT32 rolloverSetting);

The rollover parameter specifies what rollover behavior the timers will have.
A timer set to rollover, will reload with all ones when the timer reaches 
zero.  A timer that does not rollover will reload with the value of the 
Base count register.  The Base count register value is set be the 
sysMpc8540TmrStart routine, based on the interval of the timer.  The 
following rollover settings are available:

0 All timers reload with base count.
1 Timers 1 and 2 reload with base count, timer 0 rolls over.
2 Timers 0 and 2 reload with base count, timer 1 rolls over.
3 Timer 2 reloads with base count, timers 0 and 1 roll over.
4 Timers 0 and 1 reload with base count, timer 2 rolls over.
5 Timer 1 reloads with base count, timers 0 and 2 roll over.
6 Timer 0 reloads with base count, timers 1 and 2 roll over.
7 Timers 0, 1, and 2 roll over.

When using the global timers as cascaded timers the following routines may 
be useful.

STATUS sysMpc8540CascadeTmrStart (UINT32 timer, UINT32 cycles)
UINT32 sysMpc8540CycleValueCalc (UINT32 useconds)

The routine sysMpc8540CascadeTmrStart allows the timer reload value to be set
directly without specifying an interval in microseconds.  The first parameter
is the timer number and the second parameter is the number of timer cycles.  

If INCLUDE_SHOW_ROUTINES is defined, then the following routine can be used
to display the current state of all 8 timers:

STATUS sysTmrShow (void)

This routine will display the tick timers' frequency, the global timers'
frequency, each timer's enable status, each timer's interrupt enable status,
and each timers current count value.

*/

/* includes */

#include "mpc8540.h"
#include "sysMpc8540Tmr.h"
#include "sysEpic.h"
#include "sbc8540A.h"

/* defines */

/*
 * The following offset values may be used to address each individual timer
 * register.  These values can be used with the timer number to access the 
 * specified register. For example, timer 3 compare register is located at
 * address: 
 * (SBC_32BIT_TIMER_ADRS + (SBC_TICK_TMR_OFFSET * 
 *                          (3 + 1)) + SBC_TICK_TMR_CMP_OFFSET
 */

#define	SBC_TICK_TMR_OFFSET		0x10	/* Timer base address offset */
#define	SBC_TICK_TMR_CTRL_OFFSET	0	/* Control register offset */
#define	SBC_TICK_TMR_CMP_OFFSET		0x4	/* Compare register offset */
#define	SBC_TICK_TMR_CNTR_OFFSET	0x8	/* Counter register offset */

#define SBC_TICK_TMR_ENC_BIT		0	/* Enable Counter Bit */
#define	SBC_TICK_TMR_ENC_MASK		(1 << SBC_TICK_TMR_ENC_BIT)
#define SBC_TICK_TMR_COC_BIT		1	/* Clear on Compare Bit */
#define	SBC_TICK_TMR_COC_MASK		(1 << SBC_TICK_TMR_COC_BIT)
#define SBC_TICK_TMR_COVF_BIT		2	/* Clear Overflow Bit */
#define	SBC_TICK_TMR_COVF_MASK		(1 << SBC_TICK_TMR_COVF_BIT)
#define	SBC_TICK_TMR_OVF_BIT		4	/* Overflow Bit Position */
#define	SBC_TICK_TMR_OVF_MASK		(0xf << SBC_TICK_TMR_OVF_BIT)
#define	SBC_TICK_TMR_ENINT_BIT		8	/* Enable Interrupt Bit */
#define	SBC_TICK_TMR_ENINT_MASK		(1 << SBC_TICK_TMR_ENINT_BIT)
#define	SBC_TICK_TMR_CINT_BIT		9	/* Clear Interrupt Bit*/
#define	SBC_TICK_TMR_CINT_MASK		(1 << SBC_TICK_TMR_CINT_BIT)
#define	SBC_TICK_TMR_INTS_BIT		10	/* Interrupt Status Bit*/
#define	SBC_TICK_TMR_INTS_MASK		(1 << SBC_TICK_TMR_INTS_BIT)

#define	MAX_TICK_TIMERS			4
#define MIN_TICK_TIMER_FREQ		97656 		/* Hz */
#define MAX_TICK_TIMER_FREQ		25000000	/* Hz */
#define	MAX_MPC8540_TIMERS		4
#define MPC8540_REAL_TIME_MODE_FREQ	1000000		/* Hz */

#define EPIC_TMR_ENC_BIT		31		/* Enable counter bit */
#define EPIC_TMR_ENC_MASK		(1 << EPIC_TMR_ENC_BIT)
#define EPIC_TMR_MSK_INT_BIT		31		/* Mask interrupt bit */
#define EPIC_TMR_MSK_INT_MASK		(1 << EPIC_TMR_MSK_INT_BIT)

/* Tick timer access macros */

#define TICK_TMR_ADDR(base,reg)         ((base) + (reg))
#define TICK_TMR_PTR(base,reg)          (VUINT32 *)(TICK_TMR_ADDR(base,reg))
#define TICK_TMR_READ32(base,reg)       *(TICK_TMR_PTR(base,reg))
#define TICK_TMR_WRITE32(base,reg,val)  {                                   \
                                        *(TICK_TMR_PTR(base,reg)) = (val);  \
                                        EIEIO_SYNC;                         \
                                        }
#define TICK_TMR_CNTR_REG(timer)        (UINT32)(SBC_TICK_TMR_OFFSET * \
                                        ((timer) + 1)) +               \
                                        SBC_TICK_TMR_CNTR_OFFSET
#define TICK_TMR_CTRL_REG(timer)        (UINT32)(SBC_TICK_TMR_OFFSET * \
                                        ((timer) + 1)) +               \
                                        SBC_TICK_TMR_CTRL_OFFSET
#define TICK_TMR_CMP_REG(timer)         (UINT32)(SBC_TICK_TMR_OFFSET * \
                                        ((timer) + 1)) +               \
                                        SBC_TICK_TMR_CMP_OFFSET

/* locals */

#ifdef INCLUDE_TICK_TIMERS
LOCAL BOOL isIntConnected = FALSE;
LOCAL FUNCPTR sysTickTmrRoutines [MAX_TICK_TIMERS] = {NULL};
LOCAL int sysTickTmrRoutineArgs [MAX_TICK_TIMERS] = {0x0};
#endif /* INCLUDE_TICK_TIMERS */

#ifdef INCLUDE_SHOW_ROUTINES
    static char timerShowMsgHeader[] = { "\
    Timer-Number    Enabled    Int-Enabled    Value\r\n"};
    static char timerShowMsgEntry[] = { "         %-14d%-8s %-13s%08X \r\n"};
#endif

#ifdef INCLUDE_MPC8540_TIMERS
LOCAL FUNCPTR sysMpc8540TmrRoutines [MAX_MPC8540_TIMERS] = {NULL};
LOCAL int sysMpc8540TmrRoutineArgs [MAX_MPC8540_TIMERS] = {0x0};
#endif /* INCLUDE_MPC8540_TIMERS */

/* forward declarations */

#ifdef TMR_DEBUG
LOCAL STATUS sysMpc8540TmrUserHandler (UINT32);
#endif /* TMR_DEBUG */

#ifdef INCLUDE_TICK_TIMERS
LOCAL void sysTickTmrInt ();
LOCAL void sysTickTmrIntEnable (int);
LOCAL UINT32 sysTickTmrModeGet (UINT32);
LOCAL BOOL sysTickTmrIntStatusGet (UINT32);
LOCAL STATUS sysTickTmrIntStatusClr (UINT32);
#endif /* INCLUDE_TICK_TIMERS */

#ifdef INCLUDE_MPC8540_TIMERS
LOCAL void sysMpc8540TmrInt (UINT32);
LOCAL void sysMpc8540TmrIntEnable (int);
LOCAL void sysMpc8540TmrIntDisable (UINT32);
#endif /* INCLUDE_MPC8540_TIMERS */

/* externals */

IMPORT UINT32 sysCpuBusSpd ();

#ifdef INCLUDE_SHOW_ROUTINES 
/*******************************************************************************
*
* sysTmrShow - display the current state of all timers.
*
* This routine displays the current state of all the Mpc8540 timers.
*
* RETURNS: Always OK.
*/

STATUS sysTmrShow (void)
    {
    int x;
    BOOL isEnabled = FALSE;
    BOOL intEnabled = FALSE;

#ifdef INCLUDE_TICK_TIMERS
    printf("Tick Timer Frequency = 0x%x Hz\n", sysTickTmrFreqGet());
    printf("\nTICK TIMERS\n");
#endif /* INCLUDE_TICK_TIMERS */

#ifdef INCLUDE_MPC8540_TIMERS
    printf("Global Timer Frequency = 0x%x Hz\n", sysMpc8540TmrFreqGet());
#endif /* INCLUDE_MPC8540_TIMERS */

    printf(timerShowMsgHeader);

#ifdef INCLUDE_TICK_TIMERS
    for (x=0; x < MAX_TICK_TIMERS; x++)
        {
	isEnabled = (TICK_TMR_READ32 (SBC_32BIT_TIMER_ADRS,  
                     (TICK_TMR_CTRL_REG(x))) & 
                     SBC_TICK_TMR_ENC_MASK);

	intEnabled = (TICK_TMR_READ32 (SBC_32BIT_TIMER_ADRS,  
                      (TICK_TMR_CTRL_REG(x))) & 
                       SBC_TICK_TMR_ENINT_MASK);
        printf(
            timerShowMsgEntry,
            x,
            isEnabled ? "Y" : "N",
            intEnabled ? "Y" : "N",
            sysTickTmrValueGet(x)
            );
        }
#endif /* INCLUDE_TICK_TIMERS */

#ifdef INCLUDE_MPC8540_TIMERS
    printf("\nMPC8540 GLOBAL TIMERS\n");
    for (x=0; x < MAX_MPC8540_TIMERS; x++)
        {
        isEnabled = (CCSR_READ32 (CCSBAR, (CCSR_GLBL_GTBCR0 + (x * 0x40)))
                     & ~EPIC_TMR_ENC_MASK); 
        intEnabled = !(CCSR_READ32 (CCSBAR, (CCSR_GLBL_GTVPR0 + (x * 0x40)))
                       & EPIC_TMR_MSK_INT_MASK);
        printf(
            timerShowMsgEntry,
            (x),
            isEnabled ? "Y" : "N",
            intEnabled ? "Y" : "N",
            sysMpc8540TmrValueGet(x)
            );
        }
#endif /* INCLUDE_MPC8540_TIMERS */

    return (OK);
    }
#endif /* INCLUDE_SHOW_ROUTINES */ 

#ifdef INCLUDE_MPC8540_TIMERS
/*******************************************************************************
*
* sysMpc8540TmrValueGet - get the current counter value of the given global
*                         timer.
*
* This routine will return the current counter value of the specified 
* global timer.
*
* RETURNS: current counter value of timer.
*/

UINT32 sysMpc8540TmrValueGet
    (
    UINT32 timer        /* number of timer */
    )
    {
    UINT32 tmrCounterVal = 0;

    tmrCounterVal = CCSR_READ32 (CCSBAR, (CCSR_GLBL_GTCCR0 + (timer * 0x40)));
    return (tmrCounterVal);
    }

/*******************************************************************************
*
* sysMpc8540TmrConnectRoutine - connect user specified interrupt handler
*
* This routine connects a user specifed interrupt handler routine to be
* called by the timer's interrupt handler.
*
* RETURNS: OK if routine not already connected, ERROR otherwise.
*/

STATUS sysMpc8540TmrConnectRoutine
    (
    FUNCPTR routine,    /* user-defined routine */
    int arg,            /* argument */
    int timer           /* number of timer */
    )
    {
    if (timer >= MAX_MPC8540_TIMERS)
        {
#ifdef TMR_DEBUG
        printf("Timer number must be between 0 - %d\n\r",
               (MAX_MPC8540_TIMERS - 1));
#endif /* TMR_DEBUG */
        return (ERROR);
        }

    if (sysMpc8540TmrRoutines[timer] == NULL)
        {
        sysMpc8540TmrRoutines[timer] = routine;
        sysMpc8540TmrRoutineArgs[timer] = arg;
        return (OK);
        }
    else
        {
#ifdef TMR_DEBUG
        printf("Routine already connected\n");
#endif /* TMR_DEBUG */
        return (ERROR);
        }
    }

/*******************************************************************************
*
* sysMpc8540TmrDisconnectRoutine - disconnect user specified interrupt
* handler
*
* This routine disconnects a user specifed interrupt handler routine
* from the timer's interrupt handler.
*
* RETURNS: OK if successfully disconnected, ERROR otherwise.
*/

STATUS sysMpc8540TmrDisconnectRoutine
    (
    UINT32 timer        /* number of timer */
    )
    {
    if (timer >= MAX_MPC8540_TIMERS)
        {
#ifdef TMR_DEBUG
        printf("Timer number must be between 0 - %d\n\r",
               (MAX_MPC8540_TIMERS - 1));
#endif /* TMR_DEBUG */
        return (ERROR);
        }
    sysMpc8540TmrRoutines[timer] = NULL;
    sysMpc8540TmrRoutineArgs[timer] = 0x0;
    return (OK);
    }

/*******************************************************************************
*
* sysMpc8540TmrInt - timer interrupt handler
*
* This routine is the interrupt handler for all global timers.
*
* RETURNS: N/A
*/

LOCAL void sysMpc8540TmrInt 
    (
    UINT32 timer
    )
    {
#ifdef TMR_DEBUG
    logMsg ("DEBUG: Received interrupt for global timer #%d\n",
            timer,0,0,0,0,0);
#endif /* TMR_DEBUG */

    /* call user-specified routine */

    if (sysMpc8540TmrRoutines[timer] != NULL)
        {
        (*sysMpc8540TmrRoutines[timer])(sysMpc8540TmrRoutineArgs[timer]);
        }
    }

/*******************************************************************************
*
* sysMpc8540TmrIntEnable - enable timer interrupt for global timer.
*
* This routine enables a timer interrupt for the specified global timer.
*
* RETURNS: N/A
*/

LOCAL void sysMpc8540TmrIntEnable
    (
    int timer        /* number of timer */
    )
    {

    /* enable timer interrupt */

    intEnable (EPIC_VEC_GT_IRQ0 + timer);
    return;
    }

/*******************************************************************************
*
* sysMpc8540TmrIntDisable - disable timer interrupt for global timer
*
* This routine disables a timer interrupt for the specified global timer.
*
* RETURNS: N/A
*/

LOCAL void sysMpc8540TmrIntDisable 
    (
    UINT32 timer        /* number of timer */
    )
    {
    intDisable (EPIC_VEC_GT_IRQ0 + timer);
    }

/*******************************************************************************
*
* sysMpc8540TmrInit - timer initialization routine
*
* This routine initializes an mpc8540 timer.
*
* RETURNS: OK if timers are initialized successfully, ERROR otherwise.
*/

STATUS sysMpc8540TmrInit ()
    {
    int timer;
    STATUS status = OK;

    for (timer=0; timer < MAX_MPC8540_TIMERS; timer++)
        {
        status = intConnect (INUM_TO_IVEC((EPIC_VEC_GT_IRQ0 + timer)),
                             (VOIDFUNCPTR)sysMpc8540TmrInt, timer);
        if(!(status == OK))
           return(status);
#ifdef TMR_DEBUG
        sysMpc8540TmrConnectRoutine((FUNCPTR)sysMpc8540TmrUserHandler, 
                                    timer, timer);
#endif /* TMR_DEBUG */
        }
    return(status);    
    }

/*******************************************************************************
*
* sysMpc8540TmrStart - start an mpc8540 timer
*
* This routine configures (based on user input), and starts, an mpc8540 global
* timer.
*
* RETURNS: OK if timer successfully started, ERROR otherwise.
*/

STATUS sysMpc8540TmrStart
    (
    UINT32 timer,       /* number of timer */
    UINT32 useconds	/* number of useconds to trigger interrupt */
    )
    {
    UINT32 maxuSeconds = 0x0;
    UINT32 timerRate = 0x0;
    UINT32 counterValue = 0x0;
    UINT32 tmrCtrlEnableMask;

    if (timer >= MAX_MPC8540_TIMERS)
        {
#ifdef TMR_DEBUG
        printf("Timer number must be between 0 - %d\n\r",
               (MAX_MPC8540_TIMERS - 1));
#endif /* TMR_DEBUG */
        return (ERROR);
        }

#ifdef INCLUDE_AUX_CLK
    if (timer == MPC8540_AUXCLK_TIMER)
        {
#ifdef TMR_DEBUG
        printf("Timer %d is used for the AuxClock\n\r", timer);
#endif /* TMR_DEBUG */
        return (ERROR);
        }
#endif /* INCLUDE_AUX_CLK */

    if (useconds == 0x0)
        {
#ifdef TMR_DEBUG
        printf("Timer duration must be greater than 0\n");
#endif /* TMR_DEBUG */
        return (ERROR);
        }
    timerRate = sysMpc8540TmrFreqGet();
    counterValue = (timerRate / 1000000) * useconds;
    maxuSeconds = (0x7fffffff / timerRate) * 1000000;
    if (useconds > maxuSeconds)
        {
#ifdef TMR_DEBUG
        printf("Timer cannot be configured for 0x%x microseconds -\n", 
               useconds); 
        printf("duration too long for the current frequency of 0x%x Hz!\n", 
               timerRate);
        printf("The maximum value allowed is 0x%x microseconds.\n", 
               maxuSeconds);
#endif /* TMR_DEBUG */
        return (ERROR);
        }

    tmrCtrlEnableMask = counterValue & ~EPIC_TMR_ENC_MASK;
    CCSR_WRITE32 (CCSBAR, CCSR_GLBL_GTBCR0 + (timer * 0x40), 
                  tmrCtrlEnableMask); 
    sysMpc8540TmrIntEnable(timer);
    return (OK);
    }

/*******************************************************************************
*
* sysMpc8540CascadeTmrStart - start an mpc8540 timer as a cascaded timer.
*
* This routine starts an MPC8540 timer with the value specified by cycles. 
*
* RETURNS: OK if timer successfully started, ERROR otherwise.
*/

STATUS sysMpc8540CascadeTmrStart
    (
    UINT32 timer,       /* number of timer */
    UINT32 cycles       /* number of cycles before reloading timer */
    )
    {
    if (timer >= MAX_MPC8540_TIMERS)
        {
#ifdef TMR_DEBUG
        printf("Timer number must be between 0 - %d\n\r",
               (MAX_MPC8540_TIMERS - 1));
#endif /* TMR_DEBUG */
        return (ERROR);
        }

#ifdef INCLUDE_AUX_CLK
    if (timer == MPC8540_AUXCLK_TIMER)
        {
#ifdef TMR_DEBUG
        printf("Timer %d is used for the AuxClock\n\r", timer);
#endif /* TMR_DEBUG */
        return (ERROR);
        }
#endif /* INCLUDE_AUX_CLK */

    if (cycles == 0x0)
        {
#ifdef TMR_DEBUG
        printf("Timer cycles must be greater than 0\n");
#endif /* TMR_DEBUG */
        return (ERROR);
        }

    CCSR_WRITE32 (CCSBAR, CCSR_GLBL_GTBCR0 + (timer * 0x40), 
                  (cycles & ~EPIC_TMR_ENC_MASK));
    sysMpc8540TmrIntEnable(timer);
    return (OK);
    }

/*******************************************************************************
*
* sysMpc8540CycleValueCalc - Calculate the number of timer cycles for the 
*                          specified number of microseconds.
*
* This routine calculates the number of cycles for a global timer based on the
* time parameter. 
*
* RETURNS: cycles if valid, ERROR otherwise.
*/

UINT32 sysMpc8540CycleValueCalc
    (
    UINT32 useconds
    )
    {
    UINT32 timerRate = 0;
    UINT32 cycles = 0;
    UINT32 maxuSeconds = 0;

    timerRate = sysMpc8540TmrFreqGet();
    cycles = (timerRate / 1000000) * useconds;
    maxuSeconds = (0x7fffffff / timerRate) * 1000000;
    
    if (useconds > maxuSeconds)
        {
#ifdef TMR_DEBUG
        printf("Timer cannot be configured for 0x%x microseconds -\n", 
                useconds);
        printf("duration too long for the current frequency of 0x%x Hz!\n",
               timerRate);
        printf("The maximum value allowed is 0x%x microseconds.\n",
               maxuSeconds);
#endif /* TMR_DEBUG */
        return (ERROR);
        }
    return (cycles);
    }

/*******************************************************************************
*
* sysMpc8540TmrDisable - Disable an mpc8540 global Timer
*
* This routine will disable an mpc8540 global timer.
*
* RETURNS: OK if successfully disabled, ERROR otherwise.
*/

STATUS sysMpc8540TmrDisable
    (
    UINT32 timer        /* number of timer */
    )
    {

    if (timer >= MAX_MPC8540_TIMERS)
        {
#ifdef TMR_DEBUG
        printf("Timer number must be between 0 - %d\n\r",
               (MAX_MPC8540_TIMERS - 1));
#endif /* TMR_DEBUG */
        return (ERROR);
        }
    CCSR_WRITE32 (CCSBAR, CCSR_GLBL_GTBCR0 + (timer * 0x40), EPIC_TMR_ENC_MASK);
    sysMpc8540TmrIntDisable(timer);
    return (OK);
    }

/*******************************************************************************
*
* sysMpc8540TmrFreqGet - Get frequency of global timers.
*
* This routine will get the frequency of global timers. 
*
* RETURNS: frequency if successful, or ERROR otherwise. 
*/

UINT32 sysMpc8540TmrFreqGet ()
    {
    UINT32 frequency;
    UINT32 clkr;

    if (!((CCSR_READ32 (CCSBAR, CCSR_GLBL_TCR) >> 16) & 0x00000001))
        {
        clkr = CCSR_READ32 (CCSBAR, CCSR_GLBL_TCR) >> 8;
        switch (clkr)
        {
        case 0:
            clkr = 8;
            break;
        case 1:
            clkr = 16;
            break;
        case 2:
            clkr = 32;
            break;
        case 3:
            clkr = 64;
            break;
        }
        frequency = sysCpuBusSpd() / clkr; /* Hz */
        }
    else
        {
        frequency = MPC8540_REAL_TIME_MODE_FREQ;
        }
    return (frequency);
    }

/*******************************************************************************
*
* sysMpc8540TmrCascade - Sets the Cascade mode for the global timers. 
*
* This routine will set the Cascade mode for the global timers as described in
* target.nr.   
*
* RETURNS: Always OK. 
*/

STATUS sysMpc8540TmrCascade
    (
    UINT32 setting	/* 0 - 7 as described in target.nr */
    )
    {
    UINT32 TmrCascMask;
    int timer = 0;
    BOOL tmrIsEnabled = FALSE;
    STATUS status = OK;

    for (timer=0; (timer < MAX_MPC8540_TIMERS) & !tmrIsEnabled; timer++)
        {
        tmrIsEnabled = (CCSR_READ32 (CCSBAR, (CCSR_GLBL_GTBCR0 +
                        (timer * 0x40))) & ~EPIC_TMR_ENC_MASK);
        }

    if (!tmrIsEnabled)
        {
        if (setting == 0) /* Disable rollover */
            sysMpc8540TmrRolloverSet(setting);
        TmrCascMask = 0x00000007;
        setting = setting & TmrCascMask;

        CCSR_WRITE32 (CCSBAR, CCSR_GLBL_TCR, ((CCSR_READ32 (CCSBAR, 
                      CCSR_GLBL_TCR) & ~TmrCascMask) | setting));
        }
    else
        {
#ifdef TMR_DEBUG
        printf("All global timers must be disabled before cascading is"
               " modified!\n");
#endif /* TMR_DEBUG */
        status = ERROR;
        }
    return (status);
    }

/*******************************************************************************
*
* sysMpc8540TmrSrcSet - Sets the source of the global timers to be CCB. 
*
* This routine will set the source of the global timers to the CCB frequency, 
* or to the real-time clock frequency.  Beware, changing the clock source will 
* affect the behavior of the AuxClock.
*
* RETURNS: Always OK. 
*/

STATUS sysMpc8540TmrSrcSet
    (
    UINT32 rtc		/* 0 = frequency based on the CCB clock, 1 = RTC */
    )
    {
    UINT32 tmrRtmMask;
    BOOL tmrIsEnabled = FALSE;
    STATUS status = OK;
    int timer = 0;

    for (timer=0; (timer < MAX_MPC8540_TIMERS) & !tmrIsEnabled; timer++)
        {
        tmrIsEnabled = (CCSR_READ32 (CCSBAR, (CCSR_GLBL_GTBCR0 +
                        (timer * 0x40))) & ~EPIC_TMR_ENC_MASK);
        }

    tmrRtmMask = 0x00000001 << 16;
    if ((rtc == 1) & !tmrIsEnabled)
        {
        CCSR_WRITE32 (CCSBAR, CCSR_GLBL_TCR,
                      (CCSR_READ32 (CCSBAR, (CCSR_GLBL_TCR))) | tmrRtmMask);
        }
    else if ((rtc == 0) & !tmrIsEnabled)
        {
        CCSR_WRITE32 (CCSBAR, CCSR_GLBL_TCR,
                      (CCSR_READ32 (CCSBAR, (CCSR_GLBL_TCR))) & ~tmrRtmMask);
        }
    else
        {
#ifdef TMR_DEBUG
        printf("Global timers must be disabled before real-time mode is"
               " changed!\n");
#endif /* TMR_DEBUG */
        status = ERROR;
        }
    return (status);
    }

/*******************************************************************************
*
* sysMpc8540TmrClockRatioSet - Sets the Clock ratio for the global timers. 
*
* This routine will set the Clock ratio.  Beware, changing the clock ratio 
* will affect the behavior of the AuxClock.
* 
*
* RETURNS: OK if clock ratio is set, ERROR otherwise. 
*/

STATUS sysMpc8540TmrClockRatioSet
    (
    UINT32 ratio	/* 0 - 3 */
    )
    {
    UINT32 TmrClkrMask;
    BOOL tmrIsEnabled = FALSE;
    STATUS status = OK;
    int timer = 0;

    for (timer=0; (timer < MAX_MPC8540_TIMERS) & !tmrIsEnabled; timer++)
        {
        tmrIsEnabled = (CCSR_READ32 (CCSBAR, (CCSR_GLBL_GTBCR0 +
                        (timer * 0x40))) & ~EPIC_TMR_ENC_MASK);
        }

        TmrClkrMask = 0x00000003 << 8;

    if (!tmrIsEnabled)
        {

        if (!((CCSR_READ32 (CCSBAR, CCSR_GLBL_TCR) >> 16) & 0x00000001))
            {

            /* Clear Clock Ratio bits */
    
            CCSR_WRITE32 (CCSBAR, CCSR_GLBL_TCR, 
                          (CCSR_READ32 (CCSBAR, CCSR_GLBL_TCR) & ~TmrClkrMask));

            /* Set the CLKR with new ratio value */
    
            CCSR_WRITE32 (CCSBAR, CCSR_GLBL_TCR, 
                          (CCSR_READ32 (CCSBAR, CCSR_GLBL_TCR) | (ratio << 8)));
            }
        else
            {
#ifdef TMR_DEBUG
            printf("The global timer clock ratio is ignored when in"
                   " real-time mode!\n");
#endif /* TMR_DEBUG */
            status = ERROR;
            }
        }
    else
        {
#ifdef TMR_DEBUG
        printf("The global timers must be disabled before the clock ratio"
               " can be modified!\n");
#endif /* TMR_DEBUG */
        status = ERROR;
        }
    return (status);
    }

/*******************************************************************************
*
* sysMpc8540TmrRolloverSet - Sets the ROVR bits of the Global Timer Control Reg.
*
* This routine will set the ROVR bits of the Global Timer Control Register
* as documented in target.nr. 
*
* RETURNS: OK if cascading is already enabled, ERROR otherwise. 
*/

STATUS sysMpc8540TmrRolloverSet
    (
    UINT32 rollover	/* 0 - 7 as described in target.nr */
    )
    {
    UINT32 TmrROVRMask;
    UINT32 TmrCascMask;
    BOOL tmrIsEnabled = FALSE;
    BOOL cascadeIsEnabled;
    STATUS status = OK;
    int timer = 0;

    TmrROVRMask = 0x00000007 << 24;
    TmrCascMask = 0x00000007;

    /* Check to make sure cascading is enabled */

    cascadeIsEnabled = CCSR_READ32 (CCSBAR, CCSR_GLBL_TCR) & TmrCascMask;

    for (timer=0; (timer < MAX_MPC8540_TIMERS) & !tmrIsEnabled; timer++)
        {
        tmrIsEnabled = (CCSR_READ32 (CCSBAR, (CCSR_GLBL_GTBCR0 + 
                        (timer * 0x40))) & ~EPIC_TMR_ENC_MASK);
        }

    if (!cascadeIsEnabled & !(rollover == 0))
        {
#ifdef TMR_DEBUG
        printf("Cascading must be enabled before Rollover is enabled!\n");
#endif /* TMR_DEBUG */
        status = ERROR;
        }
    else if (tmrIsEnabled)
        {
#ifdef TMR_DEBUG
        printf("All global timers must be disabled before Rollover setting"
               " is modified!\n");
#endif /* TMR_DEBUG */
        status = ERROR;
        }
    else
        {

        /* Clear Rollover bits */

        CCSR_WRITE32 (CCSBAR, CCSR_GLBL_TCR, 
                      (CCSR_READ32 (CCSBAR, CCSR_GLBL_TCR) & ~TmrROVRMask));

        /* Set the ROVR with new setting */

        CCSR_WRITE32 (CCSBAR, CCSR_GLBL_TCR, 
                      (CCSR_READ32 (CCSBAR, CCSR_GLBL_TCR) | (rollover << 24)));
        }
    return (status);
    }
#endif /* INCLUDE_MPC8540_TIMERS */

#ifdef INCLUDE_TICK_TIMERS
/*******************************************************************************
*
* sysTickTmrValueGet - get the current counter value of the given tick timer.
*
* This routine will return the current counter value of the specified tick timer
*
* RETURNS: current counter value of timer.
*/

UINT32 sysTickTmrValueGet
    (
    UINT32 timer        /* number of timer */
    )
    {
    UINT32 tmrCounterVal = 0;

    tmrCounterVal = TICK_TMR_READ32 (SBC_32BIT_TIMER_ADRS, 
                                     TICK_TMR_CNTR_REG(timer)); 
    return (tmrCounterVal);
    }

/*******************************************************************************
*
* sysTickTmrConnectRoutine - connect user specified interrupt handler
*
* This routine connects a user specifed interrupt handler routine to be
* called by the timer's interrupt handler.
*
* RETURNS: OK if routine not already connected, ERROR otherwise.
*/

STATUS sysTickTmrConnectRoutine
    (
    FUNCPTR routine,    /* user-defined routine */
    int arg,            /* argument */
    int timer           /* number of timer */
    )
    {
    if (timer >= MAX_TICK_TIMERS)
        {
#ifdef TMR_DEBUG
        printf("Timer number must be between 0 - %d\n\r",
               (MAX_TICK_TIMERS - 1));
#endif /* TMR_DEBUG */
        return (ERROR);
        }

    if (sysTickTmrRoutines[timer] == NULL)
        {
        sysTickTmrRoutines[timer] = routine;
        sysTickTmrRoutineArgs[timer] = arg;
        return (OK);
        }
    else
        {
#ifdef TMR_DEBUG
        printf("Routine already connected\n");
#endif /* TMR_DEBUG */
        return (ERROR);
        }
    }

/*******************************************************************************
*
* sysTickTmrDisconnectRoutine - disconnect user specified interrupt
* handler
*
* This routine disconnects a user specifed interrupt handler routine
* from the timer's interrupt handler.
*
* RETURNS: OK if successfully disconnected, ERROR otherwise.
*/

STATUS sysTickTmrDisconnectRoutine
    (
    UINT32 timer        /* number of timer */
    )
    {
    if (timer >= MAX_TICK_TIMERS)
        {
#ifdef TMR_DEBUG
        printf("Timer number must be between 0 - %d\n\r",
               (MAX_TICK_TIMERS - 1));
#endif /* TMR_DEBUG */
        return (ERROR);
        }

    sysTickTmrRoutines[timer] = NULL;
    sysTickTmrRoutineArgs[timer] = 0x0;
    return (OK);
    }

/*******************************************************************************
*
* sysTickTmrInt - timer interrupt handler for tick timers.
*
* This routine is the interrupt handler for tick timers.
*
* RETURNS: N/A
*/

LOCAL void sysTickTmrInt ()
    {
    int timer = 0;

    while (timer < MAX_TICK_TIMERS)
        {
        if (sysTickTmrIntStatusGet(timer))
            {
#ifdef TMR_DEBUG
            logMsg ("DEBUG: Received interrupt for tick timer #%d\n",
                    timer,0,0,0,0,0);
#endif /* TMR_DEBUG */

            /* clear interrupt */

            sysTickTmrIntStatusClr(timer);
            if (!sysTickTmrModeGet(timer))
                {
                sysTickTmrDisable(timer);
                }

            /* call user-specified routine */

            if (sysTickTmrRoutines[timer] != NULL)
                {
                (*sysTickTmrRoutines[timer])(sysTickTmrRoutineArgs[timer]);
                }
            }
        else
            {
            timer++;
            }
        }
    }

/*******************************************************************************
*
* sysTickTmrIntEnable - enable timer interrupt for tick timer.
*
* This routine enables a timer interrupt for the specified tick timer.
*
* RETURNS: N/A
*/

LOCAL void sysTickTmrIntEnable
    (
    int timer        /* number of timer */
    )
    {

    /* enable timer interrupt */

    if (timer < MAX_TICK_TIMERS)
        {
        TICK_TMR_WRITE32 (SBC_32BIT_TIMER_ADRS, 
                          TICK_TMR_CTRL_REG(timer),
                          ((TICK_TMR_READ32 (SBC_32BIT_TIMER_ADRS, 
                          (TICK_TMR_CTRL_REG(timer)))) 
                          | SBC_TICK_TMR_ENINT_MASK)); 
        intEnable (TMR_CNTR0_INT_LVL);
        }
    }

/*******************************************************************************
*
* sysTickTmrIntDisable - disable timer interrupt for tick timer.
*
* This routine disables a timer interrupt for the specified tick timer.
*
* RETURNS: N/A
*/

LOCAL void sysTickTmrIntDisable 
    (
    UINT32 timer        /* number of timer */
    )
    {
    TICK_TMR_WRITE32 (SBC_32BIT_TIMER_ADRS, TICK_TMR_CTRL_REG(timer), 
                      ((TICK_TMR_READ32 (SBC_32BIT_TIMER_ADRS, 
                      (TICK_TMR_CTRL_REG(timer)))) 
                      & ~SBC_TICK_TMR_ENINT_MASK));
     }

/*******************************************************************************
*
* sysTickTmrInit - Tick timer initialization routine
*
* This routine initializes all four tick timers.
*
* RETURNS: OK if timers are initialized successfully, ERROR otherwise.
*/

STATUS sysTickTmrInit ()
    {
    int timer;
    STATUS status = OK;

    for (timer=0; timer < MAX_TICK_TIMERS; timer++)
        {
        sysTickTmrDisable(timer); 
 
        /* connect timer interrupt */
    
        if (!isIntConnected)
            {
            status = intConnect (INUM_TO_IVEC(TMR_CNTR0_INT_VEC),
                                         (VOIDFUNCPTR)sysTickTmrInt, 0); 
            isIntConnected = (status == OK);
            if (!isIntConnected)
                return(isIntConnected);
            }
#ifdef TMR_DEBUG
        sysTickTmrConnectRoutine((FUNCPTR)sysMpc8540TmrUserHandler, 
                                 timer, timer);
#endif /* TMR_DEBUG */
        }
    return(isIntConnected);
    }

/*******************************************************************************
*
* sysTickTmrStart - start an external tick timer
*
* This routine configures and starts an external tick timer. 
* 
*
* RETURNS: OK if timer is successfully started, ERROR otherwise.
*/

STATUS sysTickTmrStart
    (
    UINT32 timer,       /* number of timer */
    UINT32 useconds,	/* number of microseconds to trigger interrupt */
    UINT16 mode		/* mode of timer 1,0 (one time interrupt or periodic */
    )
    {
    UINT32 maxuSeconds = 0x0;
    UINT32 timerRate = 0x0;
    UINT32 counterValue = 0x0;
    UINT32 tmrCtrlEnableMask;
    UINT32 prescalerValue;
    STATUS status = OK;

    if (timer >= MAX_TICK_TIMERS)
        {
#ifdef TMR_DEBUG
        printf("Timer number must be between 0 - %d\n\r",
               (MAX_TICK_TIMERS - 1));
#endif /* TMR_DEBUG */
        return (ERROR);
        }

    if (useconds == 0x0)
        {
#ifdef TMR_DEBUG
        printf("Timer duration must be greater than 0\n");
#endif /* TMR_DEBUG */
        return (ERROR);
        }

    if (mode == 0)
        {
        tmrCtrlEnableMask = SBC_TICK_TMR_ENC_MASK | SBC_TICK_TMR_COC_MASK;
        }
    else
        {
	
        /* Clear the Clear on Compare bit.  This bit is used by the 
         * interrupt handler to determine whether the timer is in 
         * periodic interrupt mode or one-time interrupt mode.
         */ 

        TICK_TMR_WRITE32 (SBC_32BIT_TIMER_ADRS, (TICK_TMR_CTRL_REG(timer)),
                          (TICK_TMR_READ32 (SBC_32BIT_TIMER_ADRS, 
                          (TICK_TMR_CTRL_REG(timer))) & 
                          ~SBC_TICK_TMR_COC_MASK));
        tmrCtrlEnableMask = SBC_TICK_TMR_ENC_MASK & ~SBC_TICK_TMR_COC_MASK;
        }

    prescalerValue = ((TICK_TMR_READ32 (BRD_PRESCALER_REG, 0) >> 24));

    if (prescalerValue <= 231)
        {
        timerRate = (MAX_TICK_TIMER_FREQ / (256 - prescalerValue));
        counterValue = (timerRate / 1000000) * useconds;
        maxuSeconds = 0xffffffff;
        }
    else
        {
        timerRate = (MAX_TICK_TIMER_FREQ / (256 - prescalerValue));
        counterValue = (timerRate / 1000000) * useconds;
        maxuSeconds = (0xffffffff / timerRate) * 1000000;
        }

    if (useconds > maxuSeconds)
        {
#ifdef TMR_DEBUG
        printf("Timer cannot be configured for 0x%x microseconds-\n", 
               useconds);
        printf("duration too long for the current frequency of %d!\n", 
                timerRate);
        printf("The maximum value allowed is 0x%x microseconds.\n", 
               maxuSeconds);
#endif /* TMR_DEBUG */
        return (ERROR);
        }

    /* clear timer counter register*/ 

    TICK_TMR_WRITE32 (SBC_32BIT_TIMER_ADRS, TICK_TMR_CNTR_REG(timer), 0);

    /* Set time between interrupts (timer cycles)*/

    TICK_TMR_WRITE32 (SBC_32BIT_TIMER_ADRS, TICK_TMR_CMP_REG(timer), 
                      counterValue);	

    /* enable timer */

    TICK_TMR_WRITE32 (SBC_32BIT_TIMER_ADRS, TICK_TMR_CTRL_REG(timer), 
                      ((TICK_TMR_READ32 ( SBC_32BIT_TIMER_ADRS, 
                        TICK_TMR_CTRL_REG(timer))) | tmrCtrlEnableMask));
    sysTickTmrIntEnable(timer);
    return (status);
    }

/*******************************************************************************
*
* sysTickTmrDisable - Disable an external tick timer
*
* This routine will disable an external tick timer.
*
* RETURNS: OK if successfully disabled, ERROR otherwise.
*/

STATUS sysTickTmrDisable
    (
    UINT32 timer        /* number of timer */
    )
    {

    if (timer >= MAX_TICK_TIMERS)
        {
#ifdef TMR_DEBUG
        printf("Timer number must be between 0 - %d\n\r",
               (MAX_MPC8540_TIMERS - 1));
#endif /* TMR_DEBUG */
        return (ERROR);
        }

    TICK_TMR_WRITE32 (SBC_32BIT_TIMER_ADRS, TICK_TMR_CTRL_REG(timer),
                      ((TICK_TMR_READ32 (SBC_32BIT_TIMER_ADRS, 
                      TICK_TMR_CTRL_REG(timer))) & ~SBC_TICK_TMR_ENC_MASK));
    sysTickTmrIntDisable(timer);
    
    return (OK);
    }

/*******************************************************************************
*
* sysTickTmrFreqGet - Get frequency of tick timers.
*
* This routine will get the frequency of tick timers. 
*
* RETURNS: frequency.
*/

UINT32 sysTickTmrFreqGet 
    (
    UINT32 timer
    )
    {
    UINT8 prescalerVal;
    UINT32 frequency;

    prescalerVal = (TICK_TMR_READ32 (BRD_PRESCALER_REG, 0) >> 24);
    frequency = MAX_TICK_TIMER_FREQ / (256 - prescalerVal); 
    return (frequency);
    }

/*******************************************************************************
*
* sysTickTmrModeGet - Read the Clear-on-Compare bit of the tick timer control
*                     register.
*
* This routine will read bit 1 of the timer control register (COC).
* This bit is used to determine the mode of the timer. (periodic or one-time
* interrupt) 
*
* RETURNS: 1 for periodic mode, and 0 for one-time interrupt mode. 
*/

LOCAL UINT32 sysTickTmrModeGet
    (
    UINT32 timer	/* timer number */
    )
    {

    return ((TICK_TMR_READ32 (SBC_32BIT_TIMER_ADRS, TICK_TMR_CTRL_REG(timer)) & 
            SBC_TICK_TMR_COC_MASK) >> 1);
    }

/*******************************************************************************
*
* sysTickTmrOverflowClear - Clear the overflow bits of the timer control reg. 
*
* This routine will clear bits 4-7 of the timer control register. 
*
* RETURNS: Always OK.
*/

STATUS sysTickTmrOverflowClear
    (
    UINT32 timer	/* timer number 0 - 3 */
    )
    {
    CCSR_WRITE32 (SBC_32BIT_TIMER_ADRS, TICK_TMR_CTRL_REG(timer),
                  ((CCSR_READ32 (SBC_32BIT_TIMER_ADRS, 
                  (TICK_TMR_CTRL_REG(timer))) | SBC_TICK_TMR_COVF_MASK)));
    return (OK);
    }

/*******************************************************************************
*
* sysTickTmrOverflowValGet - Read the overflow bits of thetimer control reg.
*
* This routine will read bits 4-7 of the timer control register (OVF). 
*
* RETURNS: value of the Overflow bits. 
*/

UINT32 sysTickTmrOverflowValGet
    (
    UINT32 timer	/* timer number 0 - 3 */
    )
    {
    return ((CCSR_READ32 (SBC_32BIT_TIMER_ADRS, TICK_TMR_CTRL_REG(timer)) 
            >> 4) & 0x000f);
    }

/*******************************************************************************
*
* sysTickTmrIntStatusGet - Read the INTS bit of a timer control register.
*
* This routine will read the INTS bit of a timer control register. 
*
* RETURNS: TRUE if interrupt status bit is set.  Otherwise False. 
*/

LOCAL BOOL sysTickTmrIntStatusGet
    (
    UINT32 timer	/* timer number 0 - 3 */
    )
    {
    if (TICK_TMR_READ32 (SBC_32BIT_TIMER_ADRS, TICK_TMR_CTRL_REG(timer)) 
        & SBC_TICK_TMR_INTS_MASK)
        return(TRUE);
    else
        return(FALSE); 
    }

/*******************************************************************************
*
* sysTickTmrIntStatusClr - Clear the interrupt status bit of a tick timer 
*                          control register.
*
* This routine will clear the interrupt status bit of a tick timer control reg.
*
* RETURNS: Always OK. 
*/

LOCAL STATUS sysTickTmrIntStatusClr
    (
    UINT32 timer	/* timer number 0 - 3 */
    )
    {
    TICK_TMR_WRITE32 (SBC_32BIT_TIMER_ADRS, TICK_TMR_CTRL_REG(timer), 
                      ((TICK_TMR_READ32 (SBC_32BIT_TIMER_ADRS, 
                      TICK_TMR_CTRL_REG(timer))) | SBC_TICK_TMR_CINT_MASK));

    return (OK);
    }

/*******************************************************************************
*
* sysTickTmrFreqSet - Set frequency of tick timers.
*
* This routine will set the frequency of tick timers.
*
* RETURNS: OK if successfully set, ERROR otherwise.
*/

STATUS sysTickTmrFreqSet
    (
    UINT32 frequency        /* frequency of timers in Hertz*/
    )
    {
    UINT8 prescalerVal;

    if ((frequency < MIN_TICK_TIMER_FREQ) | (frequency > MAX_TICK_TIMER_FREQ))
        {
#ifdef TMR_DEBUG
        printf("Frequency must be between 0x%x - 0x%x\n\r",
               MIN_TICK_TIMER_FREQ, MAX_TICK_TIMER_FREQ);
#endif /* TMR_DEBUG */
        return (ERROR);
        }

    prescalerVal = 256 - (MAX_TICK_TIMER_FREQ/frequency);
    TICK_TMR_WRITE32 (BRD_PRESCALER_REG, 0, (prescalerVal << 24));
    return (OK);
    }
#endif /* INCLUDE_TICK_TIMERS */

#ifdef TMR_DEBUG
#if ((defined INCLUDE_MPC8540_TIMERS) || (defined INCLUDE_TICK_TIMERS))
/*******************************************************************************
*
* sysMpc8540TmrUserHandler - Displays the interrupt number on the screen. 
*
* This routine will send a log message to the console for debug purposes. 
*
* RETURNS: Always OK. 
*/

LOCAL STATUS sysMpc8540TmrUserHandler
    (
    UINT32 timer	/* timer number */
    )
    {
    logMsg("UserHandler called for timer #%d.\n\n",timer,0,0,0,0,0);

    return (OK);
    }
#endif /*  (defined INCLUDE_MPC8540_TIMERS) || (defined INCLUDE_TICK_TIMERS)) */
#endif /* TMR_DEBUG */
