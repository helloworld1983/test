/* sysMpc8641Smc.c - Support for the MPC8641's DDR Memory Controller */

/*
 * Copyright (c) 2008 Wind River Systems, Inc.
 *
 * The right to copy, distribute, modify or otherwise make use
 * of this software may be licensed only pursuant to the terms
 * of an applicable Wind River license agreement.
 */

/* Copyright 2004-2005 Motorola, Inc., All Rights Reserved */

/*
modification history
--------------------
01i,17mar08,mdg  Updated for the mv7100/8641D.
01h,14oct05,efb  Added DDR11 errata workaround to memory controller init.
01g,28aug05,efb  Removed core freq global. Moved core freq calc to sysLib.c
01f,15aug05,efb  Added dynamically calculated sysCpuBusSpd routine.
01e,12aug05,pjh  removed sysCpuBusSpd routine.
01d,17mar05,cak  Added a 200 microsecond delay following initialization of
         clock configuration registers before enabling the DRAM banks,
         as per Section 9.6.1 in the MPC8641 Reference Manual.
01c,07feb05,cak  Removed unnecessary code.
01b,06jan05,cak  Adjusted to hard-coded SPD values to match the memory
         currently on the mv3100.
01a,27sep04,cak  Initial writing.
*/

/*
DESCRIPTION
This file contains the routines used to calculate the proper configuration
values for the MPC8641's DDR Memory Controller using information contained
in the Serial Presence Detect (SPD) EEPROMs. The SPD information is used to
determine memory timing, bank sizes and starting addresses.

CAVEATS:
This code executes very early in the startup sequence (called from romInit.s),
before the image has been copied to RAM (assuming a non-ROM image). As such,
this file must be added to the BOOT_EXTRA list in the Makefile to prevent it
from being compressed during kernel generation. Additionally, extreme caution
must be exercised when modifying these routines to prevent the use of absolute
memory addresses which reference locations in the RAM-relocated image. These
locations are invalid and references to them will cause unpredictable behavior.
Absolute memory addresses are generated by the compiler when referencing tables,
static data structures and global variables. All of these must be avoided. In
some places in the code, nested if-else constructs are used to avoid the jump
table created when a simple switch construct is used.
*/

/* includes */

#include "vxWorks.h"
#include "config.h"
#include "sysLib.h"
#include "mv7100.h"
#include "mpc8641.h"
#include "sdramSpd.h"

IMPORT STATUS sysMotI2cRead (UINT32 devAddr, UINT32 devOffset,
                                  UINT32 devAddrBytes, UCHAR *spdData,
                                  UINT32 numBytes);
IMPORT UINT32 sysTblGet (void);

/* defines */

/*
 * converts encoded value into picoseconds-per-cycle
 */

#define PSECS(N)    (((((N) >> 2) & 0x3F) * 1000) + (((N) & 0x3) * 250))

/*
 * converts picoseconds into cycle count
 */
#define CYCLES(P,C) (((P) + ((C) - 1)) / (C))

/* typedefs */

/* globals */

/* locals */

/* forward declarations */

/*******************************************************************************
*
* sysGetDdrClkRtc - DDR clock measured using RTC input
*
* This function Return DDR clock measured using RTC input.  Assumes RTC is
* fixed, known frequency.
*
* RETURNS:DdrClkRtc.
*
*/

LOCAL UINT32 sysGetDdrClkRtc (void)
    {
    UINT32 freq;
    UINT32 tblStart;
    UINT32 tblStop;

    /*
     * Initialize PIC timer to use RTC as input and
     * initialize the counter to 50msec countdown
     */
    CCSR_WRITE32(CCSBAR, EPIC_TM_CTRL, 0x10000);
    tblStart = sysTblGet();    /* Cache getTbl() */
    CCSR_WRITE32(CCSBAR, EPIC_TM0_BASE_COUNT_REG, MPC8641_RTC_FREQ/20);
    tblStart = sysTblGet();
    tblStop = tblStart;

    /*
     * Wait for PIC timer to countdown.
     */
    while( !(CCSR_READ32(CCSBAR, EPIC_TM0_CUR_COUNT_REG) & 0x80000000)) {
            tblStop = sysTblGet();
    }

    /*
     * Use timebase delta to calculate Mpx clock speed.
     */

    freq = 4*(20 * (tblStop - tblStart));

    /*
     * Restore timer settings & return result.
     */

    CCSR_WRITE32(CCSBAR, EPIC_TM_CTRL, 0x00000);
    CCSR_WRITE32(CCSBAR, EPIC_TM0_BASE_COUNT_REG, 0x80000000);
    return (freq>>1);
    }


/*******************************************************************************
*
* sysMpc8641GetSpdData - read and validate the spd information.
*
* This function reads the contents of the caller specified serial presence
* detect EEPROM and validates the checksum.
*
* RETURNS: TRUE if the SPD contents are valid, FALSE if not.
*
*/

STATUS sysMpc8641GetSpdData
    (
    UINT32 spdAddr,      /* SROM address for current bank */
    UINT32 offset,       /* first byte of SROM to read */
    UINT32 dataSize,     /* number of SROM bytes to read */
    UCHAR *spdData       /* address of caller's SPD buffer */
    )
    {
    register UCHAR checksum = 0;    /* running checksum */
    register int   index;        /* index into SPD data buffer */

    if ( sysMotI2cRead (spdAddr, offset, 1, spdData, dataSize) == OK)
        {
        for (index = 0; index < SPD_CHECKSUM_INDEX; index++)
            checksum += spdData[index];
        checksum %= 256;
        if (checksum == spdData[SPD_CHECKSUM_INDEX])
            return (OK);
        }
        return (ERROR);
    }

/*******************************************************************************
 *
 * minCasLatencyDecipher()
 *
 * description:
 *  examine the CAS latency byte (byte 18) in the SPD along with the
 *  two minimum clock cycle time bytes (bytes 23 & 25) to determine
 *  the minimum operable CAS latency.
 *
 * call:
 *  argument #1 = local bus speed
 *  argument #2 = SPD data
 *
 * return:
 *  zero        = no supported CAS latency
 *  non-zero    = supported CAS latency (encoded)
 */

UINT32 sysMpc8641MinCasLatencyDecipher
   (
   int ramClkSpeed,
   UINT8 *spdData
   )
{
    UINT32 minCasLatency = 0;
    UINT32 cycleTime;

    if ( ramClkSpeed > 384000000 )      /* 96% of 400MHz */
        {
        cycleTime = 0x25;           /* cycle time of 2.5nsecs */
        }
    else if ( ramClkSpeed > 320000000 ) /* 96% of 333MHz */
        {
        cycleTime = 0x30;           /* cycle time of 3.0nsecs */
        }
    else if ( ramClkSpeed > 256000000 ) /* 96% of 266MHz */
        {
        cycleTime = 0x3D;           /* cycle time of 3.75 nsecs */
        }
    else if ( ramClkSpeed > 240000000 ) /* 96% of 250MHz */
        {
        cycleTime = 0x40;           /* cycle time of 4.00 nsecs */
        }
    else if ( ramClkSpeed > 192000000 ) /* 96% of 200MHz */
        {
        cycleTime = 0x50;           /* cycle time of 5.0nsecs */
        }
    else if ( ramClkSpeed > 176000000 ) /* 96% of 183MHz */
        {
        cycleTime = 0x54;           /* cycle time of 5.4nsecs */
        }
    else if ( ramClkSpeed > 160000000 ) /* 96% of 167MHz */
        {
        cycleTime = 0x60;           /* cycle time of 6.0nsecs */
        }
    else if ( ramClkSpeed > 128000000 ) /* 96% of 133MHz */
        {
        cycleTime = 0x75;           /* cycle time of 7.5nsecs */
        }
    else                    /* assume bus speed 100MHz */
        {
        cycleTime = 0xA0;           /* cycle time of 10.0nsecs */
        }

    /*
     * Verify RAM speed at highest CL is faster than bus speed.
     */

    if ( cycleTime < spdData[9] )
        {
        return(0);
        }

    /*
     * DDR2 SDRAM's maximum possible CAS latency: 6
     */

    for (minCasLatency = 6; minCasLatency > 1; minCasLatency--)
        {
        if ( spdData[18] & (1 << (minCasLatency)) )
            {
            break;
            }
        }

    if ( spdData[18] & (1 << (minCasLatency-2)) && spdData[25] <= cycleTime )
        {
        minCasLatency -= 2;
        }
    else if ( spdData[18] & (1 << (minCasLatency-1)) && spdData[23] <= cycleTime )
        {
        minCasLatency -= 1;
        }

    /*
     * return the minimum CAS latency
     */

    return (minCasLatency);
}

/*******************************************************************************
 *
 * sysMpc8641SmcWriteDecoder()
 *
 * description:
 *  Write a decoder with bank base address and size.
 *
 * return:
 *  nothing
 */

void sysMpc8641SmcWriteDecoder
    (
    UINT32 controller,  /* Controller number of interest */
    UINT32 bankNum,         /* Bank number of interest */
    UINT32 baseAddress, /* Megabyte Base address for bank */
    UINT32  bankSize,   /* Size of bank */
    UINT32  bankConfig  /* Configuration of bank */
    )
{
    UINT32 endAddress;
    UINT32 controllerOffset;

    /*
     * Sanity check parameters
     */

    if(controller > 1)
        {
        return;
        }
    if(bankNum > 3)
        {
        return;
        }
    if((bankSize & 0xFFFFFF))
        {
        return;
        }

    if(controller == 0)
        {
        controllerOffset = 0x2000;
        }
    else
        {
        controllerOffset = 0x6000;
        }

    /*
     * set base address and size for DDR decoder
     * Addresses are megabyte quantities...
     */

    endAddress = baseAddress+(bankSize/(1024*1024))-1;
    CCSR_WRITE32(CCSBAR,
                 controllerOffset+(bankNum*8),
                (baseAddress << 12) | (endAddress >> 4));

    /*
     * set configuration for DDR decoder
     */

    CCSR_WRITE32(CCSBAR,
                 controllerOffset+0x80+(bankNum*4),
                 bankConfig);
}

/*******************************************************************************
 *
 * sysMpc8641SmcInitialize()
 *
 * description:
 *  Initialize the MPC8641 SMC (System Memory Controller).
 *
 * call:
 *  argument #1 = local bus speed
 *
 * return:
 *  total size of DDR SDRAM, in bytes
 */

UINT32 sysMpc8641SmcInitialize (void)
{
#if 0

    UINT32 ramClkSpeed;
    UINT32 i, j, statusVariable, tempVariable, firstPass;
    UINT32 memoryAggregate, memoryStart;
    UINT32 psecsPerCycle;

    ramClkSpeed = 1;
    i = 2;
    j = 3;
    statusVariable = 4;
    tempVariable = 5;
    firstPass = 6;
    memoryAggregate = 7;
    memoryStart = 8;
    psecsPerCycle = 9;
    return(0);
#else
    UINT32 ramClkSpeed;
    UINT32 i, j, statusVariable, tempVariable, firstPass;
    UINT32 memoryAggregate, memoryStart;
    UINT32 psecsPerCycle;

    UINT32 spdAddr[2];
    UINT8 spdData[64];

    UINT32 bankSize1[4];
    UINT32 bankConfig1[4];
    UINT32 bankSize2[4];
    UINT32 bankConfig2[4];
    UINT32 dramDensityCode;
    UINT32 ranks;

    UINT32 casLatency;
    UINT32 eccEnable = 1;       /* TRUE until proven otherwise */
    UINT32 registered;
    UINT32 refreshRate = 0;

    UINT32 Trp;
    UINT32 Trrd;
    UINT32 Trcd;
    UINT32 Tras;
    UINT32 Trfc;
    UINT32 Trc;
    UINT32 Twr;
    UINT32 Twtr;
    UINT32 Tckmax;
    UINT32 TwrAutoClk;
    UINT32 Tis;
    UINT32 Tih;
    UINT32 Tds;
    UINT32 Tdh;
    UINT32 Trtp;
    UINT32 additiveLatency;
    UINT32 Tmrd;
    UINT32 Taxpad;
    UINT32 Txp;
    UINT32 Txard;
    UINT32 Tfaw;
    UINT32 Tcke;
    int interleaveEnable=0;

    spdAddr[0] = 0xA0;
    spdAddr[1] = 0xA2;

    ramClkSpeed = sysGetDdrClkRtc();

    /*
     * initialized some variables and/or make the compiler happy
     */

    casLatency = 0;
    dramDensityCode = 0;
    refreshRate = 0;
    registered = 0;
    Tras = 0;
    Trcd = 0;
    Trp = 0;
    Trrd = 0;
    Trfc = 0;
    Trc = 0;
    Twr = 0;
    Twtr = 0;
    Tis = 0;
    Tih = 0;
    Tds = 0;
    Tdh = 0;
    Trtp = 0;
    Tckmax = 0;
    additiveLatency = 0;

    /*
     * The following timing variables are not available via SPD.   Initialize
     * them here based on the DRAM data sheet.
     */

    Tmrd = 2;
    Taxpad = 8;
    Txp = 6;
    Txard = 2;
    Tfaw = 40;
    Tcke = 3;


    bankSize1[0] = 0;
    bankSize1[1] = 0;
    bankSize1[2] = 0;
    bankSize1[3] = 0;
    bankConfig1[0] = 0;
    bankConfig1[1] = 0;
    bankConfig1[2] = 0;
    bankConfig1[3] = 0;
    bankSize2[0] = 0;
    bankSize2[1] = 0;
    bankSize2[2] = 0;
    bankSize2[3] = 0;
    bankConfig2[0] = 0;
    bankConfig2[1] = 0;
    bankConfig2[2] = 0;
    bankConfig2[3] = 0;

    /*
     * set picoseconds per cycle value based on local bus speed
     */

    if ( ramClkSpeed > 384000000 )          /* 96% of 400Hz */
        {
        psecsPerCycle = 2500;               /* 2500 picoseconds (2.5nsecs) */
        }
    else if ( ramClkSpeed > 320000000 )     /* 96% of 333MHz */
        {
        psecsPerCycle = 3000;               /* 3000 picoseconds (3.0nsecs) */
        }
    else if ( ramClkSpeed > 256000000 )     /* 96% of 266MHz */
        {
        psecsPerCycle = 3750;               /* 3750 picoseconds (3.75nsecs) */
        }
    else if ( ramClkSpeed > 240000000 )     /* 96% of 250MHz */
        {
        psecsPerCycle = 4000;               /* 4000 picoseconds (4.00nsecs) */
        }
    else if ( ramClkSpeed > 192000000 )     /* 96% of 200MHz */
        {
        psecsPerCycle = 5000;               /* 5000 picoseconds (5.0nsecs) */
        }
    else if ( ramClkSpeed > 176000000 )     /* 96% of 183MHz */
        {
        psecsPerCycle = 5400;               /* 5400 picoseconds (5.4nsecs) */
        }
    else if ( ramClkSpeed > 160000000 )     /* 96% of 167MHz */
        {
        psecsPerCycle = 6000;               /* 6000 picoseconds (6.0nsecs) */
        }
    else if ( ramClkSpeed > 128000000 )     /* 96% of 133MHz */
        {
        psecsPerCycle = 7500;               /* 7500 picoseconds (7.5nsecs) */
        }
    else                                    /* assume bus speed 100MHz */
        {
        psecsPerCycle = 10000;              /* 10000 picoseconds (10.0nsecs) */
        }

    /*
     * Read SPD data.
     */

    for ( firstPass = TRUE, j = 0; (j < 1); j++ )
        {

        /*
         * Read SPD
         */

        spdData[0] = 0xFF;
        statusVariable = sysMpc8641GetSpdData(spdAddr[j],0,sizeof(spdData),spdData);

        /*
         * SPD not detected
         */

        if ( statusVariable == ERROR )
            {
            return(0);
            }

        /*
         * check for unprogrammed or invalid SPD contents.
         */

        if ( spdData[0] == 0xFF )
            {

            /* SPD SROM content is invalid */

            return(0);
            }
        else
            {
            tempVariable = spdData[63];
            for(i = 0; i < 63; i++)
                {
                tempVariable -= spdData[i];
                }
            if(tempVariable&0xFF)
                {

                /* RAM failure: SPD checksum error */

                return(0);
                }
            }

        /*
         * verify memory type as SDRAM DDR
         */

        if ( spdData[2] != 0x08 )
            {
            return(0);
            }

        /*
         * verify number of banks
         */

        ranks = (spdData[5] & 0x7) + 1;
        if ( ranks > 2 )
            {
            return(0);
            }

        /*
         * verify SDRAM module width
         */

        if ( spdData[6] != 64 && spdData[6] != 72 )
            {
            return(0);
            }

        /*
         * calculate bank size
         *
         * spdData[3]  = rows
         * spdData[4]  = columns
         * spdData[17] = internal banks
         */

        bankSize1[j] = (0x1 << (spdData[3] + spdData[4])) * spdData[17] * 8;
        if(bankSize1[j] > 0x40000000)
            {
            interleaveEnable = 0;
            }
        else
            {
            interleaveEnable = 1;
            }

        /*
         * Disable interleaving on MVME7100 Rev A boards.  It does not work.
         * Rev A boards have a 16 bit boot bank width, Rev B is 32.  This
         * provides an easy way to determine whether we are on Rev A or not.
         */

        if((CCSR_READ32(CCSBAR,CCSR_BR0) & 0x1800) == 0x1000)
            {
            interleaveEnable = 0;   /* On Rev A, never interleave.. */
            }

        *((volatile UINT8 *) 0xe2000002) = 2;
        bankConfig1[j] = ( 1<<31 |
                           (interleaveEnable << 29) |
                           (1 << 16) |
                           ((spdData[17] & 0x8) << (14-3)) |
                           (spdData[3]-12)<<8 |
                           (spdData[4]-8) );

        bankSize2[j] = bankSize1[j];
        bankConfig2[j] = bankConfig1[j];
        if(ranks > 1)
            {
            bankSize1[j+1] = bankSize1[j];
            bankConfig1[j+1] = bankConfig1[j];
            bankSize2[j+1] = bankSize2[j];
            bankConfig2[j+1] = bankConfig2[j];
            }

        /*
         * check ECC capability
         */

        if ( spdData[11] != 0x02 )
            {
            eccEnable = 0;          /* disable ECC */
            }

        /*
         * refresh rate
         */

        if ((spdData[12] & 0x7F) == 1)
            {
            tempVariable = 3900; /* reduced refresh: 0.25x, 3.9 usecs */
            }
        else if ((spdData[12] & 0x7F) == 2)
            {
            tempVariable = 7800; /* reduced refresh: 0.50x, 7.8 usecs */
            }
        else if ((spdData[12] & 0x7F) == 3)
            {
            tempVariable = 15625*2; /* extended refresh rate: 31.3 usecs */
            }
        else if ((spdData[12] & 0x7F) == 4)
            {
            tempVariable = 15625*4; /* extended refresh rate: 62.5 usecs */
            }
        else if ((spdData[12] & 0x7F) == 5)
            {
            tempVariable = 15625*8; /* extended refresh rate: 125 usecs */
            }
        else
            {
            tempVariable = 15625; /* normal refresh rate: 15.625usecs */
            }

        if ( firstPass || tempVariable < refreshRate )
            {
            refreshRate = tempVariable;
            }

        /*
         * CAS latency
         */

        tempVariable = sysMpc8641MinCasLatencyDecipher(ramClkSpeed, &spdData[0]);

        if ( firstPass || tempVariable > casLatency )
            {
            casLatency = tempVariable;
            }

        /*
         * check for registered SDRAM
         */

        tempVariable = spdData[20] & 0x1;

        if ( firstPass )            /* check for first iteration of loop */
            {
            registered = tempVariable;
            }
        else if ( registered != tempVariable )
            {

            /*
             * all SDRAM must be either registered or unregistered
             */

            return(0);
            }

        /*
         * collect the larger Trp, Trrd, Trcd & Tras values
         */

        if ( firstPass || spdData[27] > Trp )
            {
            Trp = spdData[27];
            }
        if ( firstPass || spdData[28] > Trrd )
            {
            Trrd = spdData[28];
            }
        if ( firstPass || spdData[29] > Trcd )
            {
            Trcd = spdData[29];
            }
        if ( firstPass || spdData[30] > Tras )
            {
            Tras = spdData[30];
            }
        if ( firstPass || spdData[32] > Tis )
            {
            Tis = spdData[32];
            }
        if ( firstPass || spdData[33] > Tih )
            {
            Tih = spdData[33];
            }
        if ( firstPass || spdData[34] > Tds )
            {
            Tds = spdData[34];
            }
        if ( firstPass || spdData[35] > Tdh )
            {
            Tdh = spdData[35];
            }
        if ( firstPass || spdData[36] > Twr )
            {
            Twr = spdData[36];
            }
        if ( firstPass || spdData[37] > Twtr )
            {
            Twtr = spdData[37];
            }
        if ( firstPass || spdData[38] > Trtp )
            {
            Trtp = spdData[38];
            }
        if ( firstPass || spdData[41] > Trc )
            {
            Trc = spdData[41];
            if(spdData[40] & 0x70)
                Trc++;
            }
        if ( firstPass || spdData[42] > Trfc )
            {
            Trfc = spdData[42];
            if(spdData[40] & 0x01)
                Trfc += 0x100;
            if(spdData[40] & 0x0E)
                Trfc++;
            }
        if ( firstPass || spdData[43] > Tckmax )
            {
            Tckmax = spdData[43];
            }

        /*
         * all variables now have an initial value
         */

        firstPass = FALSE;
        }

    /*
     * If valid SPD information was found, then use it to program
     * memory controller.  Otherwise probe for memory.
     */

    if ( firstPass == FALSE )
        {

        /*
         * program the SMC registers with information extracted
         * from the SPDs
         *
         * notes:
         * There are two memory controllers in the MPC8641 and on the
         * MVME7100, we are guaranteed that both controllers are
         * populated identically with a single bank of RAM.
         */

        /*
         * program the SDRAM refresh interval
         */

        tempVariable = (CYCLES((refreshRate * 1000), psecsPerCycle)-0x40) << 16;
        tempVariable |= 0x0100;
        CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_INTERVAL(0), tempVariable);
        CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_INTERVAL(1), tempVariable);

        /*
         * Convert values into clock cycles.
         */

        Tckmax = (((Tckmax & 0xF0) >> 4) * 1000);
        TwrAutoClk = (Tckmax -1 + Twr * 250)/Tckmax;
        Trp  = CYCLES(PSECS(Trp),  psecsPerCycle); /* convert into cycle count */
        Trrd = CYCLES(PSECS(Trrd), psecsPerCycle); /* convert into cycle count */
        Trcd = CYCLES(PSECS(Trcd), psecsPerCycle); /* convert into cycle count */
        Tras = CYCLES((Tras*1000), psecsPerCycle); /* convert into cycle count */
        Trfc = CYCLES((Trfc*1000), psecsPerCycle); /* convert into cycle count */
        Trc  = CYCLES((Trc*1000),  psecsPerCycle); /* convert into cycle count */
        Twr  = CYCLES((Twr*250),   psecsPerCycle); /* convert into cycle count */
        Twtr = CYCLES((Twtr*250),  psecsPerCycle); /* convert into cycle count */
        Trtp = CYCLES((Trtp*250),  psecsPerCycle); /* convert into cycle count */

        /*
         * Calculate additive latency...  AL + CL must be greater than 3.
         * AL must be less than Trcd
         */

        if(casLatency <= 3)
            {
            additiveLatency = 4 - casLatency;
            if (additiveLatency >= Trcd)
                {
                additiveLatency = Trcd - 1;
                }
            }

        /*
         * program TIMING_CFG_3
         */

        tempVariable = (((Trfc-8) & 0x70) >> 4) << 16;
        CCSR_WRITE32(CCSBAR, CCSR_TIMING_CFG_3(0), tempVariable);
        CCSR_WRITE32(CCSBAR, CCSR_TIMING_CFG_3(1), tempVariable);

        /*
         * program TIMING_CFG_1
         *
         * PSECS converts an encoded value into picoseconds-per-cycle
         * CYCLES converts picoseconds-per-cycle into a minimum cycle count
         *
         */

        tempVariable = 0;
        tempVariable |= ((Trp)  << 28);
        tempVariable |= ((Tras) << 24);
        tempVariable |= ((Trcd) << 20);
        tempVariable |= (((2*casLatency-1) & 0xF) << 16);
        tempVariable |= (((Trfc - 8) & 0xF) << 12);
        tempVariable |= ((Twr)  << 8);
        tempVariable |= ((Trrd) << 4);
        tempVariable |= ((Twtr) << 0);
        CCSR_WRITE32(CCSBAR, CCSR_TIMING_CFG_1(0), tempVariable);
        CCSR_WRITE32(CCSBAR, CCSR_TIMING_CFG_1(1), tempVariable);

        /*
         * program TIMING_CFG_2
         */

        tempVariable = CYCLES(Tfaw*1000, psecsPerCycle);
        tempVariable |= (Tcke << 6);
        tempVariable |= (3 << 10);
        tempVariable |= ((Trtp)  << 13);
        tempVariable |= ((casLatency-1) << 19);
        tempVariable |= (0xA << 23);
        tempVariable |= (additiveLatency  << 28);
        CCSR_WRITE32(CCSBAR, CCSR_TIMING_CFG_2(0), tempVariable);
        CCSR_WRITE32(CCSBAR, CCSR_TIMING_CFG_2(1), tempVariable);

        /*
         * program TIMING_CFG_0
         */

        tempVariable = Tmrd & 0xF;
        tempVariable |= (Taxpad << 8);
        tempVariable |= (Txp << 16);
        tempVariable |= (Txard << 20);
        CCSR_WRITE32(CCSBAR, CCSR_TIMING_CFG_0(0), tempVariable);
        CCSR_WRITE32(CCSBAR, CCSR_TIMING_CFG_0(1), tempVariable);

        /*
         * program the SDRAM mode registers
         */

        tempVariable = 0x00000000;
        tempVariable |= (additiveLatency << 19);
        tempVariable |= (1 << 18);
        tempVariable |= (TwrAutoClk << 9);
        if (casLatency == 2)
            {
            tempVariable |= 0x22;
            }
        else if (casLatency == 3)
            {
            tempVariable |= 0x32;
            }
        else if (casLatency == 4)
            {
            tempVariable |= 0x42;
            }
        else if (casLatency == 5)
            {
            tempVariable |= 0x52;
            }
        else
            {
            tempVariable |= 0x62;
            }
        CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_MODE(0), tempVariable);
        CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_MODE(1), tempVariable);
        CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_MODE_2(0), 0);
        CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_MODE_2(1), 0);


        }
    else
        {

        /*
         * "firstPass" is still true, so no valid SPD contents
         * were found.  Leave DRAM settings at default values
         * and probe for RAM.
         */
        /* probing not implemented yet... */

        }

    /*
     * Disable all SDRAM decoders.   These should already be cleared
     * by reset but just in case....
     */

    CCSR_WRITE32(CCSBAR, CCSR_CS0_CONFIG(0), 0);
    CCSR_WRITE32(CCSBAR, CCSR_CS0_CONFIG(1), 0);
    CCSR_WRITE32(CCSBAR, CCSR_CS1_CONFIG(0), 0);
    CCSR_WRITE32(CCSBAR, CCSR_CS1_CONFIG(1), 0);
    CCSR_WRITE32(CCSBAR, CCSR_CS2_CONFIG(0), 0);
    CCSR_WRITE32(CCSBAR, CCSR_CS2_CONFIG(1), 0);
    CCSR_WRITE32(CCSBAR, CCSR_CS3_CONFIG(0), 0);
    CCSR_WRITE32(CCSBAR, CCSR_CS3_CONFIG(1), 0);

    /*
     * program the SDRAM decoders.   On the MVME7100, there are 2 banks
     * and they are always identical.   This simplifies mapping...
     */

    memoryAggregate = 0;
    memoryStart = 0;
    if(interleaveEnable)
        {
        sysMpc8641SmcWriteDecoder(0, 0, 0, bankSize1[0]*2, bankConfig1[0]);
        sysMpc8641SmcWriteDecoder(1, 0, 0, bankSize2[0]*2, bankConfig1[0]);
        memoryAggregate += ((bankSize1[0]/(1024*1024))*2);
        }
    else
        {
        sysMpc8641SmcWriteDecoder(0, 0, 0, bankSize1[0], bankConfig1[0]);
        memoryAggregate += (bankSize1[0]/(1024*1024));
        memoryStart += (bankSize1[0]/(1024*1024));
        if(bankSize1[1] != 0)
            {
            sysMpc8641SmcWriteDecoder(0, 1, memoryStart,
                                      bankSize1[1], bankConfig1[1]);
            memoryAggregate += (bankSize1[1]/(1024*1024));
            memoryStart += (bankSize1[1]/(1024*1024));
            }
        if(memoryStart >= 0x800)
            {
            memoryStart = 0x1000; /* More than 2 Gig gos to
                                     next 4 Gig boundary*/
            }
        sysMpc8641SmcWriteDecoder(1, 0, memoryStart,
                                  bankSize2[0], bankConfig2[0]);
        memoryAggregate += (bankSize2[0]/(1024*1024));
        memoryStart += (bankSize2[0]/(1024*1024));
        if(bankSize2[1] != 0)
            {
            sysMpc8641SmcWriteDecoder(1, 1, memoryStart,
                                      bankSize2[1], bankConfig2[1]);
            memoryAggregate += (bankSize2[1]/(1024*1024));
            }
        }

    /*
     * program the SDRAM configuration registers
     */

    tempVariable = CCSR_READ32(CCSBAR, CCSR_DDR_SDRAM_CFG(0)) & 0x08D100C4;
    tempVariable |= (1 << 30);            /* SDRAM self refresh enabled */
    tempVariable |= (eccEnable << 29);
    tempVariable |= (registered << 28);
    tempVariable |= (3 << 24);            /* DDR2 */
    tempVariable |= (1 << 15);            /* 2T timing enabled */
    CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_CFG(0), tempVariable);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_CFG(1), tempVariable);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_CFG_2(0), 0x04401010);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_CFG_2(1), 0x04401010);

    /*
     * program miscellaneous DRAM registers.
     */

    CCSR_WRITE32(CCSBAR, CCSR_DDR_DATA_INIT(0), 0);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_DATA_INIT(1), 0);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_INIT_ADDR(0), 0);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_INIT_ADDR(1), 0);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_INIT_EXT_ADDR(0), 0);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_INIT_EXT_ADDR(1), 0);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_CLK_CTRL(0), 7 << 23);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_CLK_CTRL(1), 7 << 23);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_CDR1(0), 0x80000000);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_CDR1(1), 0x80000000);
    CCSR_WRITE32(CCSBAR, CCSR_ERR_DETECT(0),
                 CCSR_READ32(CCSBAR, CCSR_ERR_DETECT(0)));
    CCSR_WRITE32(CCSBAR, CCSR_ERR_DETECT(1),
                 CCSR_READ32(CCSBAR, CCSR_ERR_DETECT(1)));

    /*
     * Allow 200 usecs to elapse to allow memory clocks to stabilize (i.e.,
     * initialization is complete of all clock related registers). This is
     * a requirement per the MPC8641 reference manual.
      mpc8641Delay(200);
     */

    /*
     * Enable memory by programming the SDRAM configuration register.
     */

    tempVariable = CCSR_READ32(CCSBAR, CCSR_DDR_SDRAM_CFG(0)) & 0x7FFFFFFF;
    tempVariable |= (1 << 31);            /* SDRAM interface logic enabled */
    CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_CFG(0), tempVariable);
    CCSR_WRITE32(CCSBAR, CCSR_DDR_SDRAM_CFG(1), tempVariable);

    /*
     * Allow 200 usecs to elapse as a safeguard to ensure the DRAM has
     * plenty of time to program its DLLs.
     * mpc8641Delay(200);
     */

    /*
     * If we enabled automatic data init, wait for it to complete.
     */
#if 0
    for(j = 0; j < 15*1000; j++)
        {
        mpc8641Delay(1000);
        if(((CCSR_READ32(CCSBAR, CCSR_DDR_SDRAM_CFG_2) & 0x10) == 0) &&
           ((CCSR_READ32(CCSBAR, CCSR_DDR_2_SDRAM_CFG_2) & 0x10) == 0))
            {
            break;
            }

        }
    if (j == 15*1000)
        {
        return(0);
        }
#endif

    /*
     * Setup LAW registers for DRAM.
     */

    CCSR_WRITE32(CCSBAR, CCSR_LAWAR1, 0);
    CCSR_WRITE32(CCSBAR, CCSR_LAWAR8, 0);
    CCSR_WRITE32(CCSBAR, CCSR_LAWBAR1, 0);
    if(interleaveEnable)
        {
        for(j = 10; j < 0x20; j++)
            {
            if(((2 << j) >> 19) > memoryAggregate)
                {
                break;
                }
            }
        CCSR_WRITE32(CCSBAR, CCSR_LAWAR1, 0x80B00000+j);
        }
    else
        {
        CCSR_WRITE32(CCSBAR, CCSR_LAWBAR8, (memoryAggregate/2) << (20-12));
        for(j = 10; j < 0x20; j++)
            {
            if(((2 << j) >> 19) > (memoryAggregate/2))
                {
                break;
                }
            }
        CCSR_WRITE32(CCSBAR, CCSR_LAWAR1, 0x80F00000+j);
        CCSR_WRITE32(CCSBAR, CCSR_LAWAR8, 0x81600000+j);
        }

    /*
    * return memory size
    */
   return (memoryAggregate);
#endif
}
