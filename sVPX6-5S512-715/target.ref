\" target.ref - Freescale QorIQ P5020/P3041DS target specific documentation
\"
\" Copyright (c) 2011, 2012 Wind River Systems, Inc.
\"
\" The right to copy, distribute, modify or otherwise make use
\" of this software may be licensed only pursuant to the terms
\" of an applicable Wind River license agreement.
\"
\" modification history
\" --------------------
\" 01o,25jun13,j_z  enable RapidIO port 1.(WIND00418128)
\" 01n,17nov12,j_z  updated RapidIO support.
\" 01m,25apr12,y_y  updated SATA documentation.
\" 01l,09apr12,h_k  removed SYSTEM_GLOBALS and RESERVED_ATOMICS. (WIND00341977)
\" 01k,03mar12,y_y  updated the legecy I2C driver with new vxBus I2C driver.
\" 01j,14feb12,y_y  Fixed the wrong CCSBAR from 0xfe000000 to 0xfeffffff
\"                  and code clean after the test. (WIND00333079)
\" 01i,30jan12,agf  Replace SYSTEM_GLOBALS with RESERVED_ATOMICS
\" 01h,21jan12,y_y  updated default DIP-Switch settings for P3041DS board.
\" 01g,15dec11,y_y  fix make man error in I2C chapter.
\" 01f,15nov11,y_y  updated documentation for P3041DS board.
\" 01e,15oct11,y_y  updated documentation for P5020DS board.
\" 01d,08oct11,ers  Fixed wrload description for romInit changes.
\" 01c,27sep11,ers  Replaced DYNAMIC_WRLOAD with generic wrload.  Added memory map.
\" 01b,15jun11,b_m  add instructions to program VxWorks bootrom via U-Boot.
\" 01a,11mar11,syt  Created from fsl_p4080_ds/01t
\"
\TITLE fsl_p5020_ds/fsl_p3041_ds - Freescale QorIQ P5020/P3041 DS

\sh NAME
`Freescale QorIQ P5020/P3041 DS'

INTRODUCTION

This reference entry provides board-specific information necessary to run
VxWorks for the fsl_p5020_ds/fsl_p3041_ds BSP. Please read the section "Getting 
the board running VxWorks" in order to configure the board to run VxWorks.

\sh Tested Simics Versions
The fsl_p5020_ds BSP has been tested with the following versions of Simics 4.4 
and the QorIQ P50x0 model:

\is
\i simics-pkg-1000-4.4.27
\i simics-pkg-2076-4.4.pre22
\ie

Newer version Simics models may work with the BSP out of the box, but there is
a possibilty that with Simics model changes the BSP is no longer compatible.
Please refer to Simics models release notes for detailed information.

\sh Getting the board running VxWorks (Simics)
This section will guide you on how to run VxWorks on the Freescale P5020DS
Simics model.

1. Creating scripts for P5020DS model:
    In general, all special configuration for the Simics model and loading
    vxWorks bootrom image into the target is done through a set of scripts.
    Users should create these scripts for their target first. Please refer to
    the Simics 4.4 and QorIQ P50x0 model library reference manuals to get the
    details about how to create them.

2. Creating a bootrom.bin:

    Open the VxWorks Development Shell, change directory to fsl_p5020_ds
    BSP directory, then build the VxWorks bootrom image.

\cs
    cd target/config/fsl_p5020_ds
    make bootrom.bin
\ce

3. Start vxWorks bootrom.

\sh Switches

There are ten DIP-switchs on the P5020DS/P3041DS board. Please make sure all
these switches are in the factory default state before using the VxWorks BSP.

Default DIP-Switch Settings for P5020DS:

\ts
Switch Number | Switch ON     | Switch OFF
---------------------------------------------
SW1           | 2,3,5,7       | 1,4,6,8
SW2           | 3,8           | 1,2,4,5,6,7
SW3           | 2,7           | 1,3,4,5,6,8
SW4           | 1,2,3,4,5,7,8 | 6
SW5           | 4,6           | 1,2,3,5,7,8
SW6           | 7,8           | 1,2,3,4,5,6
SW7           | 5,6,7,8       | 1,2,3,4
SW8           | 1,3,6,7       | 2,4,5,8
SW9           | 1,2,3         | 4,5,6,7,8
SW10          | 2,4           | 1,3,5,6,7,8
\te

Default DIP-Switch Settings for P3041DS:

\ts
Switch Number | Switch ON     | Switch OFF
---------------------------------------------
SW1           | 2,3,5,7       | 1,4,6,8
SW2           | 3,8           | 1,2,4,5,6,7
SW3           | 2,8           | 1,3,4,5,6,7
SW4           | 1,2,3,4,6,8   | 5,7
SW5           | 4,6           | 1,2,3,5,7,8
SW6           | 1,5,7,8       | 2,3,4,6
SW7           | 5,6,7,8       | 1,2,3,4
SW8           | 1,3,7         | 2,4,5,6,8
SW9           | 1,2,3,7       | 4,5,6,8
SW10          |               | 1,2,3,4,5,6,7,8
\te

\sh Getting the board running VxWorks (hardware)
This section will guide you on how to run VxWorks on the Freescale P5020DS/P3041DS board.

1. Creating a bootrom_uncmp.bin:

    Open the VxWorks Development Shell, change directory to fsl_p5020_ds/fsl_p3041_ds
    BSP directory, and then build the VxWorks bootrom image.

\cs
For P5020DS:

    cd target/config/fsl_p5020_ds
    make bootrom_uncmp.bin
\ce

\cs
For P3041DS:

    cd target/config/fsl_p3041_ds
    make bootrom_uncmp.bin
\ce

2. Flashing the VxWorks bootrom with U-boot

    This section will describe how to program a VxWorks bootrom into the flash
    using the pre-flashed U-Boot.

    2.1 Set the Boot Flash Switch

        Make sure U-Boot boot bank (bank#0) is selected by checking:
        SW#7[1,2,3,4] = [OFF,OFF,OFF,OFF]

    2.2 Starting a TFTP server

        Open a TFTP server on your host.  Make sure the root directory is
        your fsl_p5020_ds/fsl_p3041_ds BSP directory which contains the VxWorks 
        bootrom image you've just created.

    2.3 Make sure your host serial port's configuration is:

        Baud Rate: 115200
        Data: 8 bit
        Parity: None
        Stop: 1 bit
        Flow Control: None

    2.4 Configuring the U-Boot environment

        Power up the board, you'll see the U-Boot shell prompt, something like:

\cs
For P5020DS board:

U-Boot 2011.06-rc2 (Jun 09 2011 - 20:35:52)

CPU0:  P5020E, Version: 1.0, (0x82280010)
Core:  E5500, Version: 1.0, (0x80240010)
Clock Configuration:
       CPU0:2000 MHz, CPU1:2000 MHz, 
       CCB:800  MHz,
       DDR:666.667 MHz (1333.333 MT/s data rate) (Asynchronous), LBC:100  MHz
       FMAN1: 600 MHz
       PME:   400 MHz
L1:    D-cache 32 kB enabled
       I-cache 32 kB enabled
Board: P5020DS, Sys ID: 0x1c, Sys Ver: 0x12, FPGA Ver: 0x05, vBank: 0
36-bit Addressing
Reset Configuration Word (RCW):
       00000000: 0c540000 00000000 1e120000 00000000
       00000010: d8984a01 03002000 fe800000 41000000
       00000020: 00000000 00000000 00000000 10070000
       00000030: 00000000 00000000 00000000 00000000
SERDES Reference Clocks: Bank1=100Mhz Bank2=125Mhz Bank3=125Mhz 
I2C:   ready
SPI:   ready
DRAM:  Initializing....using SPD
Detected UDIMM i-DIMM
Detected UDIMM i-DIMM
CS2 is disabled.
CS3 is disabled.
CS2 is disabled.
CS3 is disabled.
2 GiB left unmapped
    DDR: 4 GiB (DDR3, 64-bit, CL=9, ECC on)
       DDR Controller Interleaving Mode: cache line
       DDR Chip-Select Interleaving Mode: CS0+CS1
Testing 0x00000000 - 0x7fffffff
Testing 0x80000000 - 0xffffffff
Remap DDR 2 GiB left unmapped

POST memory PASSED
Flash: 128 MiB
L2:    512 KB enabled
Corenet Platform Cache: 2048 KB enabled
SRIO1: disabled
SRIO2: disabled
NAND:  1024 MiB
MMC:  FSL_ESDHC: 0
EEPROM: NXID v1
PCIe1: Root Complex, no link, regs @ 0xfe200000
PCIe1: Bus 00 - 00
PCIe2: disabled
PCIe3: Root Complex, no link, regs @ 0xfe202000
PCIe3: Bus 01 - 01
PCIe4: disabled
In:    serial
Out:   serial
Err:   serial
Net:   Initializing Fman
Fman1: Uploading microcode version 101.8.0
PHY reset timed out
FM1@DTSEC1 connected to Generic PHY
PHY reset timed out
FM1@DTSEC2 connected to Generic PHY
PHY reset timed out
FM1@DTSEC3 connected to Generic PHY
FM1@DTSEC4 connected to Vitesse VSC8244
FM1@DTSEC5 connected to Vitesse VSC8244
PHY reset timed out
FM1@TGEC1 connected to Generic 10G PHY
FM1@DTSEC1, FM1@DTSEC2, FM1@DTSEC3, FM1@DTSEC4, FM1@DTSEC5 [PRIME], FM1@TGEC1
Hit any key to stop autoboot:  0 
=>
\ce

\cs
For P3041DS board:

U-Boot 2011.06-rc2 (Jun 09 2011 - 20:15:17)

CPU0:  P3041E, Version: 1.0, (0x82190310)
Core:  E500MC, Version: 2.2, (0x80230022)
Clock Configuration:
       CPU0:1500 MHz, CPU1:1500 MHz, CPU2:1500 MHz, CPU3:1500 MHz, 
       CCB:750  MHz,
       DDR:666.667 MHz (1333.333 MT/s data rate) (Asynchronous), LBC:93.750 MHz
       FMAN1: 583.333 MHz
       PME:   375 MHz
L1:    D-cache 32 kB enabled
       I-cache 32 kB enabled
Board: P3041DS, Sys ID: 0x1c, Sys Ver: 0x12, FPGA Ver: 0x05, vBank: 0
36-bit Addressing
Reset Configuration Word (RCW):
       00000000: 12600000 00000000 241c0000 00000000
       00000010: d8984a01 03002000 fe800000 41000000
       00000020: 00000000 00000000 00000000 10070000
       00000030: 00000000 00000000 00000000 00000000
SERDES Reference Clocks: Bank1=100Mhz Bank2=125Mhz Bank3=125Mhz 
I2C:   ready
SPI:   ready
DRAM:  Initializing....using SPD
Detected UDIMM i-DIMM
    DDR: 2 GiB (DDR3, 64-bit, CL=9, ECC on)
       DDR Chip-Select Interleaving Mode: CS0+CS1
Testing 0x00000000 - 0x7fffffff
Remap DDR 
POST memory PASSED
Flash: 128 MiB
L2:    128 KB enabled
Corenet Platform Cache: 1024 KB enabled
SRIO1: disabled
SRIO2: disabled
NAND:  1024 MiB
MMC:  FSL_ESDHC: 0
EEPROM: NXID v1
PCIe1: Root Complex, no link, regs @ 0xfe200000
PCIe1: Bus 00 - 00
PCIe2: disabled
PCIe3: Root Complex, x2, regs @ 0xfe202000
  02:00.0     - 8086:105e - Network controller
  02:00.1     - 8086:105e - Network controller
PCIe3: Bus 01 - 02
PCIe4: disabled
In:    serial
Out:   serial
Err:   serial
Net:   Initializing Fman
Fman1: Uploading microcode version 101.8.0
FM1@DTSEC1 connected to Vitesse VSC8234
FM1@DTSEC2 connected to Vitesse VSC8234
FM1@DTSEC3 connected to Vitesse VSC8234
FM1@DTSEC4 connected to Vitesse VSC8244
FM1@DTSEC5 connected to Vitesse VSC8244
FM1@TGEC1 connected to Teranetics TN2020
e1000: 00:15:17:6b:12:02
e1000: 00:15:17:6b:12:02
FM1@DTSEC1, FM1@DTSEC2, FM1@DTSEC3, FM1@DTSEC4, FM1@DTSEC5 [PRIME], FM1@TGEC1, e1000#0, e1000#1
Hit any key to stop autoboot:  0 
=>
\ce

        Type the following commands to setup the U-Boot environment.

\cs
        setenv ipaddr 192.168.0.3
        setenv netmask 255.255.255.0
        setenv serverip 192.168.0.2
        setenv gatewayip 192.168.0.1
        saveenv
\ce

        Note: This is just an example, you should change the network parameters
        according to your actual environment. 'ipaddr' is the target IP address
        while 'serverip' is your host IP address.

    2.5 Programming the Freescale P5020DS/P3041DS flash

        VxWorks bootrom is stored on the bank#4 of the on-board NOR flash.
        Type the following commands in the U-Boot shell.

\cs
        tftp 1000000 bootrom_uncmp.bin
        protect off ebf00000 +100000
        erase ebf00000 +100000
        cp.b 1000000 ebf00000 100000
        protect on ebf00000 +100000
        cmp.b 1000000 ebf00000 100000
\ce

    2.6 Copy the pre-flashed RCW to the correct location for VxWorks bootrom

\cs
        protect off ec000000 +50
        erase ec000000 +50;
        cp.b e8000000 ec000000 50
        protect on ec000000 +50
        cmp.b e8000000 ec000000 50
\ce

        Note: this step only needs to be done once, when the bootrom is loaded
        onto a new board for the first time. If the bootrom is upgraded later,
        the existing copy of the RCW can be retained.

    2.7 Change SW#7 to choose VxWorks bootrom bank (bank#4)
\cs
        SW#7[1,2,3,4] = [OFF,ON,OFF,OFF]
\ce

3. Running the VxWorks bootrom
        Power the target back on. After a few seconds, the VxWorks bootrom
        banner should appear

        If this is the first time a VxWorks bootrom has been loaded onto this
        board, use the 'M' command from the [VxWorks Boot]: prompt to set the
        MAC addresses for all of the network ports. These will be stored in
        flash.

FEATURES

This section describes all features of the board, supported or not.
It documents all configurations of the board and the interaction between
features and configuration items.

\sh List of Hardware Features (Freescale P5020DS/P3041DS board)

\ts
Hardware Interface | Controller | Driver/Component    | Status
--------------------------------------------------------------
UART:0             | on-chip    | vxbNs16550Sio.c     | SUPPORTED
UART:1             | on-chip    | vxbNs16550Sio.c     | SUPPORTED
UART:2             | on-chip    | vxbNs16550Sio.c     | SUPPORTED
UART:3             | on-chip    | vxbNs16550Sio.c     | SUPPORTED
DDR3(2GB)          | INNODISK   | M3CN-2GHFHC09-D92   | SUPPORTED
1GB-ETHERNET:0     | on-chip    | vxbDtsecEnd.c       | SUPPORTED
1GB-ETHERNET:1     | on-chip    | vxbDtsecEnd.c       | SUPPORTED
1GB-ETHERNET:2     | on-chip    | vxbDtsecEnd.c       | SUPPORTED
1GB-ETHERNET:3     | on-chip    | vxbDtsecEnd.c       | SUPPORTED
1GB-ETHERNET:4     | on-chip    | vxbDtsecEnd.c       | SUPPORTED
10GB-ETHERNET:0    | on-chip    | vxbTgecEnd.c        | SUPPORTED
NOR-FLASH          | S29GL01G   | 'flashMem.c'        | SUPPORTED
NAND-FLASH         | NAND08GW3B2|                     | UNSUPPORTED
TIMER              | on-chip    | vxbM85xxTimer.c     | SUPPORTED
TIMER              | on-chip    | vxbOpenPicTimer.c   | SUPPORTED
PCI-E-HOST:0       | on-chip    | vxbQorIQPciEx.c     | SUPPORTED
PCI-E-HOST:1       | on-chip    | vxbQorIQPciEx.c     | SUPPORTED
PCI-E-HOST:2       | on-chip    | vxbQorIQPciEx.c     | SUPPORTED
PCI-E-HOST:3       | on-chip    | vxbQorIQPciEx.c     | SUPPORTED
DMA:0              | on-chip    | DRV_DMA_FSL         | SUPPORTED
DMA:1              | on-chip    | DRV_DMA_FSL         | SUPPORTED
I2C:0              | on-chip    | INCLUDE_I2C_BUS     | SUPPORTED
I2C:1              | on-chip    | INCLUDE_I2C_BUS     | UNVALIDATED
I2C:2              | on-chip    | INCLUDE_I2C_BUS     | UNVALIDATED
I2C:3              | on-chip    | INCLUDE_I2C_BUS     | SUPPORTED
RTC                | DS3232     | DRV_I2C_RTC         | SUPPORTED
EEPROM             | Atmel      | DRV_I2C_EEPROM      | SUPPORTED
SPI-FLASH          | on-chip    | DRV_SPI_S25FLXX     | SUPPORTED
USB-HOST:0         | on-chip    | INCLUDE_USB         | SUPPORTED
USB-HOST:1         | on-chip    | INCLUDE_USB         | SUPPORTED
USB-TARGET:1       | on-chip    | INCLUDE_FSL_TCD     | SUPPORTED
SATA:0             | on-chip    | DRV_STORAGE_FSLSATA | SUPPORTED
SATA:1             | on-chip    | DRV_STORAGE_FSLSATA | SUPPORTED
SD-CARD            | on-chip    | DRV_STORAGE_SDHC    | SUPPORTED
SRIO               | on-chip    | DRV_SRIO_FSL        | SUPPORTED
Security Engine    | on-chip    | -                   | UNVALIDATED
Performance Monitor| on-chip    | -                   | UNSUPPORTED
\te

\sh Feature Interactions
Refer to the board vendor's documentation.

HARDWARE DETAILS

This section documents the details of the device drivers and board hardware
elements.

\sh Verified Hardware
This BSP has been verified on a P5020DS/P3041DS rev1.0 with default clock settings.  
Note The default clock speed for P5020DS is 2GHz for core0 and core1, 800MHz for CCB.
the default clock speed for P3041DS is 1.5GHz for core0, core1, core2 and core3, 
750MHz for CCB.

\sh Memory Maps
The default hardware memory map of this BSP is as follows:

\ts
Start       | Size  | End         | Access to
---------------------------------------------
0x0000_0000 |  2GB  | 0x7FFF_FFFF | DDR3 SDRAM
0x7FD0_0000 |  2MB  | 0x7FF0_0000 | 2MB reserved memory for QMAN hardware
0x7FF0_0000 |  1MB  | 0x7FFF_FFFF | 1MB reserved memory for BMAN hardware
0x8000_0000 |  64MB | 0x83FF_FFFF | PCIe 1 Prefetchable Memory
0x8400_0000 |  64MB | 0x87FF_FFFF | PCIe 1 Non-Prefetchable Memory
0x8800_0000 |  64MB | 0x8BFF_FFFF | PCIe 1 IO
0x8C00_0000 |  64MB | 0x8FFF_FFFF | PCIe 1 IO32
0xA000_0000 |  64MB | 0xA3FF_FFFF | PCIe 2 Prefetchable Memory
0xA400_0000 |  64MB | 0xA7FF_FFFF | PCIe 2 Non-Prefetchable Memory
0xA800_0000 |  64MB | 0xABFF_FFFF | PCIe 2 IO
0xAC00_0000 |  64MB | 0xAFFF_FFFF | PCIe 2 IO32
0xC000_0000 |  64MB | 0xC3FF_FFFF | PCIe 3 Prefetchable Memory
0xC400_0000 |  64MB | 0xC7FF_FFFF | PCIe 3 Non-Prefetchable Memory
0xC800_0000 |  64MB | 0xCBFF_FFFF | PCIe 3 IO
0xCC00_0000 |  64MB | 0xCFFF_FFFF | PCIe 3 IO32
0xD000_0000 |  64MB | 0xD3FF_FFFF | PCIe 4 Prefetchable Memory
0xD400_0000 |  64MB | 0xD7FF_FFFF | PCIe 4 Non-Prefetchable Memory
0xD800_0000 |  64MB | 0xDBFF_FFFF | PCIe 4 IO
0xDC00_0000 |  64MB | 0xDFFF_FFFF | PCIe 4 IO32
0xC000_0000 | 128MB | 0xC7FF_FFFF | SRIO 1 Memory
0xC800_0000 | 128MB | 0xCFFF_FFFF | SRIO 2 Memory
0xF400_0000 |   2MB | 0xF41F_FFFF | BMAN
0xF420_0000 |   2MB | 0xF43F_FFFF | QMAN
0xFE00_0000 |  16MB | 0xFEFF_FFFF | CCSBAR
0xFF00_0000 |  16MB | 0xFFFF_FFFF | NOR FLASH
\te

The default software memory map of the fsl_p5020_ds BSP is as follows:

\ts
Start Addr  | End Addr    | Used for
---------------------------------------------
0x0000_0000 | 0x000F_FFFF | PHYS_MEM_START
0x0000_0000 | 0x3FFF_FFFF | (core 0) LOCAL_MEM_LOCAL_ADRS
0x0000_0100 | 0x0000_3500 | Vectors (3500 - Performance Mon)
0x0000_4100 | 0x0000_41FF | SM_ANCHOR
0x0000_4200 | 0x0000_42FF | BOOT_LINE
0x0000_4300 | 0x0000_43FF | EXC_MSG
0x000E_FC00 | 0x000E_FC14 | CPUn_SPACE(1) (if _WRS_CONFIG_SMP)
0x000F_0000 | 0x000F_0014 | CPUn_SPACE(0)        
0x000F_0000 | 0x000F_FFFF | root stack (core 0)
0x0010_0000 | 0x3FFF_FFFF | core 0 image/heap 
0x4000_0000 | 0x4FFF_FFFF |(core 1 static)  LOCAL_MEM_LOCAL_ADRS 
0x4000_0000 | 0x77FF_FFFF |(core 1 dynamic) LOCAL_MEM_LOCAL_ADRS 
0x4000_4400 | 0x4000_44FF | TM_ANCHOR_ADRS             
0x4001_0000 | 0x4008_FFFF | MIPC_SM_SYSTEM_POOL_BASE
0x4000_0000 | 0x40FF_FFFF | root stack (core 1)
0x4100_0000 | 0x77FF_FFFF | core 1 image/heap (RAM_LOW_ADRS)
0x7800_0000 | 0x78FF_FFFF | VIRTUAL_SM_BASE
0x7FD0_0000 | 0x7FEF_FFFF | QMAN_MEM_BASE 
0x7FF0_0000 | 0x7FFF_FFFF | BMAN_MEM_BASE
------------|-------------|-----------------
0x8000_0000 | 0x8FFF_FFFF | PCIEX1_LAW_BASE
0xA000_0000 | 0xAFFF_FFFF | PCIEX2_LAW_BASE
0xC000_0000 | 0xCFFF_FFFF | PCIEX3_LAW_BASE
0xD000_0000 | 0xDFFF_FFFF | PCIEX4_LAW_BASE
0xC000_0000 | 0xC7FF_FFFF | SRIO1 LAW Memory
0xC800_0000 | 0xCFFF_FFFF | SRIO2 LAW Memory
0xFE00_0000 | 0xFEFF_FFFF | CCSBAR
0xEFDF_0000 | 0xEFDF_0FFF | PIXIS_BASE
0xF400_0000 | 0xF41F_FFFF | BMAN_LAW_BASE
0xF420_0000 | 0xF43F_FFFF | QMAN_LAW_BASE 
0xFD00_0000 | 0xFD3F_FFFF | DCSR_LAW_BASE
0xFF00_0000 | 0xFFFF_FFFF | FLASH_BASE_ADRS
0xFFFF_FFFC |             | Reset vector (only 1, 4-K page valid).
\te

\sh Serial Configuration

UART1 as default console. If UART2 will be used, CONSOLE_TTY should be change to 
1 in config.h

Default configuration is:
    Baud Rate: 115200
    Data: 8 bit
    Parity: None
    Stop: 1 bit
    Flow Control: None

\sh Network Configuration
The DTSEC ports allow 10/100/1000 connections. The driver will auto-negotiate
and configure the port accordingly.  The BSP also supports TGEC with a 10G
connection.

The following END drivers are supported in this BSP.

\ts
Driver | END
-------------------------
DTSEC  | DRV_VXBEND_DTSEC
TGEC   | DRV_VXBEND_TGEC
\te

The P5020 processor has a total of 5 internal dtsec network controllers, spread
across one frame manager.

Using the DTSEC ports requires the DRV_VXBEND_DTSEC driver component.

In the original default factory configuration, the four DTSEC ports on FMAN1 are 
accessed via an SGMII riser card plugged into I/O slot 6.

Note: For DTSEC3, which can be worked at SGMII & RGMII mode, it deponds on 
the SerDes lane H (RCW[159] bit) and parameter DTSEC3_IN_RGMII. Only both 
of them are configured to match each othe, the DTSEC4 can work well. 
The following table can give a example how to config it:

\ts
| SerDes lane H (RCW[159]bit) | Media Mode |  DTSEC3_IN_RGMII
-------------------------------------------------------------
| powered off---(RCW[159]=1)  |  RGMII     |    TRUE
| powered on ---(RCW[159]=0)  |  SGMII     |    FALSE
\te

FMAN also has a Ten Gigabit Ethernet Controller (TGEC), a TGEC driver is supplied.
Using the TGEC ports requires the addition of a XAUI riser card, which provides 
a single 10GBase-T media port. The default P5020DS/P3041DS configuration supports 
a XAUI riser in I/O slot 2. To use the TGEC in VxWorks, the DRV_VXBEND_TGEC driver 
component must be included into the project configuration. 

The XAUI media riser card supplied by Freescale has both a 10GBase-T port
and a slot for an SFP+ module, which can accommodate a 10GBase-SR fiber
module. The card is not normally supplied with a module, and the 10GBase-T
port is usually enabled by default. Support for fiber media is available,
however some caveats apply. In order to use a fiber SFP+ module, the
XAUI card must be flashed with the latest PHY firmware. If it's set to
default to 10Gbase-T, the fiber module must be enabled via software by
accessing some MDIO registers in the PHY. This requires the use of the
TGEC MDIO driver. To select fiber media, the TGEC0_FIBER macros in config.h 
should be defined.

Both the DTSEC and TGEC drivers include support for jumbo frames.

\sh Ethernet Address
Six Ethernet hardware addresses are assigned to P5020DS/P3041DS board. A unique 
address is absolutely necessary if the user wishes to connect the board to a network.
Thus, the user must provide a suitable 6-byte Ethernet address for each on-board
network interface.

Definition of the macro ETHERNET_MAC_HANDLER in p5020ds.h indicates the MAC
address is stored in NVRAM and alterable via the 'M' bootrom command.  This
option allows only the last three bytes to be changed. To use this option,
open a console window and reset the hardware. When the bootrom banner appears
and the countdown starts, press any key to get the "[VxWorks Boot]:" prompt.
Type the 'M' command to modify the MAC address.

\sh DPAA Support

In addition to standard DTSEC and TGEC END drivers, support is also
provided for Qman, Bman and Fman DPAA components. The vxbQorIQQman,
vxbQorIQBman and vxbQorIQFman modules support the following functionality:

\is
\i User creation of Qman frame queues
\i Interrupt driven and polled Qman event handling
\i Management of Bman buffer pools
\i Use of Fman hard parser for RX checksum offload in the DTSEC and TGEC drivers
\i APIs provided to program the keygen, parser, coarse classifier and policer in the Fman
\ie

Documentation for these APIs can be found in the following files:

\is
\i target/src/hwif/resource/vxbQorIQBmanPortal.c -- Bman API
\i target/src/hwif/resource/vxbQorIQQmanPortal.c -- Qman API
\i target/src/hwif/resource/vxbQorIQQmanFman.c -- Fman API
\ie

\sh Boot Devices
The supported boot devices are:

\ts
    `dtsec0   ' | DTSEC0
    `dtsec1   ' | DTSEC1
    `dtsec2   ' | DTSEC2
    `dtsec3   ' | DTSEC3
    `dtsec4   ' | DTSEC4
    `fs       ' | USB/SD/SATA/TFFS
\te

\sh SMP

VxWorks SMP(Symmetric Multiprocessing) configuration can be used on this 
multiprocessor hardware platform supported by this BSP. Please refer to
the chapter "VxWorks SMP" of vxworks_kernel_programmers_guide_6.x.pdf for 
more details about the SMP-specific features from software and hardware view.

Here we list some key features of SMP.

1. SMP build

   VxWorks SMP can be configured and built using the standard Wind River
   Workbench and vxprj facilities. VxWorks SMP images cannot be created with the
   legacy BSP directory configuration and build method (using config.h and make).
   
   Workbench provides a VxWorks Image Project (VIP) option for creating VxWorks
   SMP projects. The vxprj provides the '-smp' option for configuring and building
   VxWorks SMP from the command line. For example:
\cs   
   vxprj create -smp fsl_p5020_ds diab or vxprj create -smp fsl_p3041_ds diab
\ce

2. Boot loader

   Boot loader for VxWorks SMP must not be built with the SMP build option-neither 
   with Workbench nor with vxprj. In other words, you can build a bootloader using 
   command line or Workbench, just like the steps you follow in UP system, the 
   bootloader will support UP, SMP and AMP.
   
3. MMU

   VxWorks SMP does not support MMU-less configuration.
   
4. Cache and bus snoop

   Snoop logic is specific to the hardware architecture, but it's usually supported
   by a multiprocessor hardware platform. Therefore, CACHE_SNOOP_ENABLE can be used 
   in BSP to maintain the system coherency. Please refer to config.h of this BSP to 
   find how CACHE_SNOOP_ENABLE is used.
   
   Note that CACHE_SNOOP_ENABLE is required in PowerPC, ARM and IA. It doesn't make
   sense in MIPS BSP.
   
   Cache can not be disabled in a VxWorks SMP system. I.e, function cacheDisable()  
   directly returns error and does nothing.
   
   Only copy-back mode is tested and supported officially by WindRiver BSP and VxWorks
   kernel for SMP system and this is the default configuration in BSP. So system may has
   unpredictable behavior if you decide to change the cache mode from copy-back to 
   write-through. In addition, there are some other reasons for this restriction. For 
   example, write-through is not supported by VxWorks for PowerPC processors because of 
   the atomic operation, and neither does ARM because of the hardware implementation.
   
5. Interrupt CPU affinity 

   Hardware resources can be allocated via VxWorks configuration. Here we focus on the 
   interrupt to show how it's implemented. SMP hardware usually requires programmable 
   interrupt controller. VxWorks SMP makes use of this hardware to allow assignment 
   interrupts to a specific CPU. By default, interrupts are routed to the VxWorks 
   instance's logical CPU 0.
   For example, in hwconf.c of this BSP, there is the following data structure:
   
   struct intrCtlrCpu epicCpu[] = { { EPIC_XX_INT_VEC, 0 },};
   
   User can reroute the interrupt to other CPUs by changing 
   0 to 1 or any other supported CPU index.
   
6. CPU number

   VxWorks project parameter, VX_SMP_NUM_CPUS, is used to represent the CPUs which 
   get involved in the SMP system, as VxWorks supports part of all the CPUs to participate
   the SMP system and the rests keep reset or idle. The CPU number we are discussing here 
   includes all the hardware units which have the same behavior as CPU, for example, the 
   thread, hyper-thread, etc.
   
   The maximum CPU number of this BSP is 2 or 4 and this is also the possible 
   maximum value of VX_SMP_NUM_CPUS.

\sh VxWorks AMP with wrload and MIPC

You must use Workbench or vxprj to build the BSPs.  
You can build any image for CPU0 from the fsl_p5020_ds or fsl_p3041_ds BSP.
This image is configured for AMP, wrload and MSD (MIPC serial device).
For CPUs 1-3 you can build a RAM based image (vxWorks) and is also configured
to be loaded by wrload and to route the console to CPU0.
See documentation on MIPC/wrload and MIPC Serial Device for details.

For instance, core 0 must be configured with the components to execute
as the primary CPU. 

\cs
$ cd $WIND_BASE/target/proj
$ vxprj create fsl_p5020_ds or fsl_p3041_ds diab amp0
& vxprj component add amp0/amp0.wpj INCLUDE_AMP INCLUDE_AMP_CPU_00 INCLUDE_WRLOAD
& vxprj build amp0/amp0.wpj
\ce                            

The images for rest cores must be configured with the components to
execute as a secondary CPU. Use vxprj to add the appropriate component, 
INCLUDE_AMP_CPU_0x. Also, vxprj automatically maintains mutual exclusion 
among the CPU components. Adding a CPU component removes the pre-existing one.

\cs
$ cd $WIND_BASE/target/proj
$ vxprj create fsl_p5020_ds or fsl_p3041_ds diab ampx
& vxprj component add ampx/ampx.wpj INCLUDE_AMP INCLUDE_AMP_CPU_0x INCLUDE_WRLOAD_IMAGE_BUILD 
& vxprj build ampx/ampx.wpj
\ce 

For P3041DS board:
* Substitute x with 1 - 3 to match CPU for which this image is targeted.

For P5020DS board:
* Substitute x only can be 1,  2 cores in all.

The following configurations are provided as optional:

\ts
| Components
-------------------------------------------------------------
| INCLUDE_MSD INCLUDE_SHELL INCLUDE_MIPC_SM INCLUDE_MIPC_SHOW
\te

Of course, Workbench may be used instead of vxprj.  Navigate the 
configuration menus thusly:
Kernel configurations: hardware -> BSP configuration variants -> VxWorks AMP core build

Boot using an image created from fsl_p5020_ds or fsl_p3041_ds BSP using vxprj or
Workbench; the default bootrom provided from the fsl_p5020_ds or fsl_p3041_ds 
BSP may be used to boot this image. See the boot loader description in 
chapter SMP above.

Call wrload using the following either add as part of the usrAppInit or call
from a shell such as the target shell.

For Example:

-> wrload "-file <image_dir>/vxWorks -cpu 1"

wrload supports modifying the bootline using "-tsym" (highly recommended to
set the network device and CPU index correctly).
See wrload documentation for details.

\sh wrload and memory management. 

wrload, executed from the primary CPU, calls the function usrWrloadMap() to
dynamically allocate virtual memory pages in the primary CPU's context for
placing the secondary image into physical memory.  The argument to
usrWrloadMap() is 'pAddr' which is set based upon the ELF file's load memory
address (LMA) plus a physical bias.

The physical bias is compiled into the loaded image via the CDF parameter 
WRLOAD_IMAGE_BUILD_PHYS_BIAS.  The value of the parameter is stored across two
32 bit variables as (_wrload_bias_high_32 | _wrload_bias_low_32). wrload, on 
the primary CPU, reads these symbols directly from the ELF file prior to 
loading.  This physical bias is superseded by wrload's -loadbias argument
(i.e. a dynamic bias not defined at build time).  Which ever value is used, 
the result is placed into the symbol _wrload_bias.

There are a few limitations when using WRLOAD_IMAGE_BUILD_PHYS_BIAS.
If the -loadbias argument is used, the primary CPU will load the image to the
physical bias specified by -loadbias, however the secondary CPU cannot execute
the image because the sysPhysMemDesc table and sysVirtToPhys routines use the
WRLOAD_IMAGE_BUILD_PHYS_BIAS macro defined at compile-time.  If a load bias is
used, the MMU no longer uses a 1-to-1 physical-to-virtual mapping.  The ICE
may require a 1-to-1 mapping (with a physical bias of 0) to properly debug
an image.  Finally, the bootrom supports but constraints the bias to lie on
a 256MB boundary.

For secondary images the bootrom (romInit) reads a shared memory area
starting at CPUn_SPACE to get the image's stack pointer, starting address
and MMU data.  The primary image sets up CPUn_SPACE from sysAmpCpuEnable().
The usrWrload functions usrWrloadBiasHighGet() and usrWrloadBiasLowGet()
are provided for sysAmpCpuEnable() to get the _wrload_bias value and put it
into CPUn_LOCAL_MEM_ERPN and CPUn_LOCAL_MEM_RPN.  The bootrom uses RPN and
ERPN to specify the (36-bit) physical address for a 256MB mapping that the
secondary image starts running in.  The corresponding virtual address is
derrived from the CPUn_FUNC_START_ADR.  Later, as the image boots and runs
sysHwInit() this initial 256MB mapping is overwritten by sysStaticTlbDesc[].
This allows the entries in sysStaticTlbDesc[] to expand (or reduce) the
image's footprint to any workable size.

The primary image's MMU does not include a mapping for the physical area
used by the secondary image(s).  This protects the secondary image(s)
from the primary.  The primary image uses usrWrloadMap() to map a virtual
scratchpad area created just to load the image.  This area must be outside
the primary's current virtual space and is typically the lower 32-bits of
the image physical address.  However, if these lower 32-bits overlap the
primary's current virtual space an error is returned and wrload will abort.
Consequently, a fixed offset wrloadPriScratchMemOffset based on the CDF
parameter WRLOAD_PRI_SCRATCH_OFFSET is added to the lower 32-bits to generate
the virtual address.

As indicated above, the image virtual address is derrived from the start
address and should be RAM_LOW_ADRS.  The physical address is equal to
the virtual address added to the WRLOAD_IMAGE_BUILD_PHYS_BIAS.  

\sh System Global Atomics and Virtual Shared Memory
This BSP contains enhanced support for AMP, allowing SMP images to participate
in AMP, and allowing SMP images to be loaded above the 32-bit boundary.  To
accommodate these features, one shared memory component has been added.

1. System Global Atomics -
The Freescale e500mc family of processors have two system-wide shared resources
which require mutual exclusion for access. The first is the 'tlbsync' instruction.
Only one core may execute it at a time. The second is the L3 cache invalidate bit.
Again, only one core is allowed access to the L3 cache when the
invalidation process is on-going. Software semaphores were created to ensure
only one processor in a mixed multi-core environment accesses these shared 
resources at a time. However, the placement of the semaphores must be at a location
which is set consistently for all operating systems and tasks executing on the
cores of the processor.

Formerly, the memory for locating the semaphores was defined by the SYSTEM_GLOBALS
feature. The component INCLUDE_SYSTEM_GLOBALS would need to be selected whenever
an AMP configuration was desired and its parameters SYSTEM_GLOBALS,
SYSTEM_GLOBALS_PHYS, and SYSTEM_GLOBALS_SIZE would define the location in memory
of the variables.

As support for additional QorIQ processors was added, it became obvious that it
made more sense to move the functionality provided by the SYSTEM_GLOBALS out of
the BSP, where it had to be re-implemented for each hardware target, and into
the arch-specific libraries, where the code could be shared and reused among 
all the processors that required the feature. With the release of VxWorks 6.9.2 UP2
SYSTEM_GLOBALS definitions in the BSP are replaced with the RESERVED_ATOMICS
functionality which is defined and initialized in the PPC architecture library.

Initialization of the RESERVED_ATOMICS data region is performed automatically
by the memory-management library. First-time users of this BSP do not need
to make any changes to their code. Support for RESERVED_ATOMICS is completely
integrated. Legacy users that have customized their BSP prior to upgrading to
vxWorks 6.9.2 UP2 will have to consider the following changes.

The RESERVED_ATOMICS_ADRS default value is 0x5000. This is identical to the 
default SYSTEM_GLOBALS_PHYS value in the vxWorks 6.9.2 BSPs. If the
SYSTEM_GLOBALS_PHYS had been modified to reference a different address, 
then the pointer to the RESERVED_ATOMICS region must also be modified. This 
should be done in the function sysHwInit() in the file sysLib.c. Also,
the memory map entry for SYSTEM_GLOBALS in the sysPhysMemDesc[] table should
be changed to use the RESERVED_ATOMICS macros. A sample of the required
code changes is below:

\cs
   /@ only add these two lines if replacing the default value of 0x5000 @/
#undef  RESERVED_ATOMICS_ADRS
#define RESERVED_ATOMICS_ADRS  <alt_address> 


PHYS_MEM_DESC sysPhysMemDesc [] =
{
   <snip>

#if ( (RESERVED_ATOMICS_ADRS <  LOCAL_MEM_LOCAL_ADRS) || \
      (RESERVED_ATOMICS_ADRS > (LOCAL_MEM_LOCAL_ADRS + LOCAL_MEM_SIZE)) )
    ,
    {
    (VIRT_ADDR) RESERVED_ATOMICS_ADRS,
    (PHYS_ADDR) RESERVED_ATOMICS_ADRS,
    MMU_PAGE_SIZE,
    VM_STATE_MASK_VALID | VM_STATE_MASK_WRITABLE | VM_STATE_MASK_CACHEABLE |
    VM_STATE_MASK_MEM_COHERENCY,
    VM_STATE_VALID      | VM_STATE_WRITABLE      | TLB_CACHE_MODE |
    VM_STATE_MEM_COHERENCY
    }
#endif /@ RESERVED_ATOMICS_ADRS @/

void sysHwInit (void)
    {

    <snip>

    /@
     * 'pReservedAtomics' should be set here only if the target is not using
     * the default RESERVED_ATOMICS_ADRS value of 0x5000.
     @/

#if (RESERVED_ATOMICS_ADRS != 0x5000)
     pReservedAtomics =  (reservedAtomics_t *) RESERVED_ATOMICS_ADRS;
#endif

     }
\ce 

Setting the pointer should only be necessary if the semaphores cannot be 
located at 0x5000, for instance to support non-vxWorks operating systems which
require a different address for shared resources.

2. Virtual Shared Memory - the INCLUDE_VIRTUAL_SM is optional, but it must
be added to any image built for loading above the 32-bit boundary utilizing
SMP or MIPC.  This component sets up a virtual to physical mapping above the
1GB (default) page mapping SDRAM, for the system globals region and/or for MIPC.

There are three configurable parameters for INCLUDE_VIRTUAL_SM: VIRTUAL_SM_BASE,
VIRTUAL_SM_BASE_PHYS, and VIRTUAL_SM_SIZE.  These specify the virtual address,
physical address, and size of the region, respectively.  These default to
0x78000000, 0x78000000, and 0x01000000.  The BSP only supports 16MB for the
size.

Note: MIPC is located in this shared memory region by default.  For this
reason, a new configurable parameter is added for the MIPC SM physical address:
MIPC_SM_SYSTEM_POOL_BASE_PHYS.  When designing a system, this physical address
should be matched with other images in the system (Linux, VxWorks, etc.).

\sh Logical Partition Support
The component INCLUDE_LOGICAL_PARTITION is provided to allow each AMP image
to have its own logical partition ID.  This is required when there is an SMP
kernel running in the system, as vxWorks SMP uses tlbivax to invalidate TLBs and
broadcast the invalidation to each of its CPUs. INCLUDE_LOGICAL_PARTITION is
automatically included when INCLUDE_AMP is selected. INCLUDE_LOGICAL_PARTITION's
configuration parameter, LOGICAL_PARTITION_ID, defaults to a unique value
based upon which INCLUDE_AMP_CPU_0x component is included.
LOGICAL_PARTITION_ID can be a value from 0 to 63.

Note: 0 indicates the global partition; 1 is reserved for Linux SMP.

\sh Boot Methods

The boot methods are affected by the boot parameters.  If no password is
specified, RSH (remote shell) protocol is used.  If a password is specified,
FTP protocol is used, or, if the flag is set to 0x80, TFTP protocol is used.

\sh Serial RapidIO Support

There are 2 RapidIO ports on this board, which share the interfaces with PCIe ports. To
enable RapidIO ports, the RCW need to be reconfigured by the tool - pbl_image_tool.html
or qoriqconfig tool. Please contact Freescale to get such configure tools.

To enable RapidIO support, make sure the following components are defined
in config.h, or add it into your VIP dynamically, the following components only enable
basic RapidIO share memory application between host and slave.

\cs
   #define INCLUDE_RAPIDIO_BUS
   #define DRV_SRIO_FSL
   #define DRV_SRIO_CPU_EP
\ce

To enable the message END driver based on RapidIO, the following components should
be added.

\cs
   #define DRV_RESOURCE_QORIQRMAN
   #define INCLUDE_MSG_NET
\ce

Note: This message END driver need a MAC address, use message net driver resource "msgNetHwAdr"
in hwconf.c to set different MAC address for different port/board.

To enable the share memory END driver based on RapidIO, the following components
should be added.

\cs
   #define DRV_RESOURCE_QORIQRMAN
   #define INCLUDE_SM_COMMON
   #define INCLUDE_SM_NET
   #define INCLUDE_SM_OBJ
   #define INCLUDE_VXBUS_SM_SUPPORT
\ce

Note:

1). The processor number in the vxWorks boot line is used to set the MAC address 
   by the share memory END driver, so must be different among the different
   RapidIO targets.
2). The backplane IP address in the vxWorks boot line is used by the share
   memory END driver.

\sh PCI Express Support

The P5020/P3041 processor has a total of 4 PCI Express controllers. The 
P5020/P3041 DS factory default configuration supports PCIEX1 and PCIEX3, which 
are wired to I/O slot 4 and 7. Use of the PCIe slots requires the DRV_PCIBUS_QORIQ_PCIEX 
driver component. Adding INCLUDE_PCI_BUS with vxprj or from Workbench will 
automatically add that component, as well as INCLUDE_PCI_BUS_AUTOCONF, which 
is also required. INCLUDE_PCI_BUS_SHOW component can optionally be included to 
add PCI show routines. Any supported vxBus PCI driver should work once the QorIQ
PCI bus controller driver is present. Tests have been done with the
INCLUDE_GEI825XX_VXB_END.

The PCIe controllers are supported in root complex mode only.

This BSP defaults to use PCIe legacy interrupts. To enable PCIe MSI interrupts,
define following macro in config.h, or add it to your project using the vxprj
tool or Workbench:

\cs
    #define INCLUDE_INTCTLR_DYNAMIC_LIB
\ce

\sh DMA
The DMA Controller is supported in this release. To enable DMA functionality, 
please define following macro in config.h, or add it to your project using 
the vxprj tool or Workbench:

\cs
    #define DRV_DMA_FSL
\ce

Note: The MAX transfer size of every slice on each DMA channel should not
exceed 0x03fff_ffff (64M - 1) bytes.

\sh SD memory card controller (eSDHC)

The P5020/P3041 on chip enhanced SD host controller (eSDHC) is supported in this 
release. Both stand capacity and high capacity SD memory cards are supported,
but MMC cards are not.

To enable eSDHC support, make sure the following feature definitions are
added in config.h:

\cs
    #define DRV_STORAGE_SDHC
\ce

When using an SD card for the first time, you should format it as a FAT file
system by using
\cs
    dosFsVolFormat ("/sd0:1", 0x20, 0);    /@ FAT32 format @/
\ce
or
\cs
    dosFsVolFormat ("/sd0:1", 0x10, 0);    /@ FAT16 format @/
\ce

Now, you can use VxWorks I/O and file system commands to access the SD card
device as if it were a disk.  For example, you can copy a vxWorks image from
your host to the SD card by using file system copy.

\cs
    copy ("vxWorks", "/sd0:1/vxWorks");
\ce
If you want to use sd card as a boot device, you should follow these steps:

For command line mode, make sure DRV_STORAGE_SDHC is defined in config.h, re-build
a bootrom from the BSP directory under VxWorks Development Shell, and program
it into the flash chip.  Also make sure you have all the necessary file system
components defined in config.h.

For project mode with PROFILE_BOOTAPP profile under Workbench, you should make
sure to include the following components in the Kernel Configuration Window:

\cs
    DRV_STORAGE_SDHC
    INCLUDE_ERF
    INCLUDE_DEVICE_MANAGER
    INCLUDE_FS_EVENT_UTIL
    INCLUDE_FS_MONITOR
    INCLUDE_XBD
    INCLUDE_XBD_BLK_DEV
    INCLUDE_XBD_TRANS
    INCLUDE_DOSFS
    INCLUDE_DOSFS_DIR_FIXED
    INCLUDE_DOSFS_DIR_VFAT
    INCLUDE_DOSFS_FAT
    INCLUDE_DOSFS_FMT
    INCLUDE_DOSFS_MAIN
    INCLUDE_DISK_UTIL
    INCLUDE_BOOT_FILESYSTEMS
\ce

Then right click the project, select "Build Options\Set Active Build Spec...",
check the "default_romCompress" box, you will see "vxWorks.bin(default_romCompress)"
item is listed in the project, right click it and select "Build Target", this
will generate a default_romCompress.bin in the project directory, program
it into the flash chip as a bootrom.

Below is an example by using /sd0:1 as a boot device:

\cs
    boot device          : fs
    unit number          : 0
    processor number     : 0
    host name            : host
    file name            : /sd0:1/vxWorks
    inet on ethernet (e) : 192.168.0.3:ffffff00
    host inet (h)        : 192.168.0.2
    gateway inet (g)     : 192.168.0.1
    user (u)             : target
    ftp password (pw)    : vxTarget
    flags (f)            : 0x0
\ce

\sh USB

The P5020/P3041DS has two USB ports, USB1 is a host-only interface and USB2 may be a 
host or device. USB Enhanced Host Controller (EHCD) driver has been integrated 
into this BSP. To enable USB host support, please define the following macro 
in config.h, or add it to your project using the vxprj tool or Workbench:

\cs
#define INCLUDE_USB
\ce

USB Mass storage device has been verified on the target.

To use the USB module in device mode, please define INCLUDE_FSL_TCD in config.h

This will add support for Target Controller Driver (TCD) for the
Freescale dual-role USB controller, and the Mass Storage device emulator which
sits on top of the TCD. The Mass Storage emulator will use a RAM disk on target
to emulate a storage disk, and when the device is attached to a USB host, it can
work like a USB flash disk, and user can try to copy data to and from the disk
or perform a disk format operation. Since it is emulation using RAM disk, the
actual storage content will be lost once power is turned off. This is
an example for users to verify that the USB device drivers are
working, and users can refer to the source code as a baseline for new
product development.

For more information, please refer to
\tb Wind River USB for VxWorks 6 PROGRAMMER'S GUIDE

If you want to use usb disk as a boot device, you should follow these steps:

For command line mode, make sure INCLUDE_USB is defined in config.h, re-build
a bootrom from the BSP directory under VxWorks Development Shell, and program
it into the flash chip. Also make sure you have all the necessary file system
components defined in config.h.

For project mode with PROFILE_BOOTAPP profile under Workbench, you should make
sure to include the following components in the Kernel Configuration Window:

\cs
    INCLUDE_ERF
    INCLUDE_DEVICE_MANAGER
    INCLUDE_FS_EVENT_UTIL
    INCLUDE_FS_MONITOR
    INCLUDE_XBD
    INCLUDE_XBD_BLK_DEV
    INCLUDE_XBD_TRANS
    INCLUDE_DOSFS
    INCLUDE_DOSFS_DIR_FIXED
    INCLUDE_DOSFS_DIR_VFAT
    INCLUDE_DOSFS_FAT
    INCLUDE_DOSFS_FMT
    INCLUDE_DOSFS_CHKDSK
    INCLUDE_DOSFS_MAIN
    INCLUDE_USB_INIT
    INCLUDE_EHCI
    INCLUDE_EHCI_INIT
    INCLUDE_USB_MS_BULKONLY
    INCLUDE_USB_MS_BULKONLY_INIT
    INCLUDE_USB_MS_CBI
    INCLUDE_USB_MS_CBI_INIT
    INCLUDE_BOOT_USB_FS_LOADER
    INCLUDE_BOOT_FILESYSTEMS
    INCLUDE_BOOT_EDR_SUPPORT
    INCLUDE_DISK_UTIL
\ce

Then right click the project, select "Build Options\Set Active Build Spec...",
check the "default_romCompress" box, you will see "vxWorks.bin(default_romCompress)"
item is listed in the project, right click it and select "Build Target", this
will generate a default_romCompress.bin in the project directory, program
it into the flash chip as a bootrom.

You should now be able to use VxWorks I/O and file system commands to access
the USB device as if it were a disk. For example, you can copy a vxWorks
image from your host to usb disk by using file system 'copy'. Of course, you must
define INCLUDE_DISK_UTIL in config.h first.

\cs
copy ("vxWorks", "/bd0/vxWorks");
\ce

Below is an example by using usb disk "/bd0" as a boot device:

\cs
    boot device          : fs
    unit number          : 0
    processor number     : 0
    host name            : host
    file name            : /bd0/vxWorks
    inet on ethernet (e) : 192.168.0.3:ffffff00
    host inet (h)        : 192.168.0.2
    gateway inet (g)     : 192.168.0.1
    user (u)             : target
    ftp password (pw)    : vxTarget
    flags (f)            : 0x0
\ce

\sh TrueFFS
The standard Wind River TrueFFS product is supported in this release.

This BSP uses the Spansion S29GL01GP flash as the TrueFFS media.
VxWorks maps 16 MB of FLASH address space at 0xff000000 - 0xffffffff.

Note:The VxWorks bootrom is stored at 0xfff00000~0xffffffff, 8 MBytes of space
(0xff000000~0xff7fffff) is used for TFFS, please don't extend the TFFS space 
before you carefully check the flash memory map, otherwise misusing TFFS may 
damage the bootloader (bootrom) and would cause the board to fail to boot up.

To use it, define INCLUDE_TFFS in config.h. When using TrueFFS on a new FLASH
for the first time, you should format and configure the FLASH by using:

\cs
    sysTffsFormat (0);
    usrTffsConfig (0, 0, "/tffs0");
\ce

If you are using DOSFS, please use

\cs
    dosfsDiskFormat ("/tffs0");
\ce

Note: If you are running these commands in the VxWorks target shell, please use

\cs
    sp sysTffsFormat
\ce

to format the FLASH as it will take long time to complete.

You should now be able to use VxWorks I/O and file system commands to access
the FLASH device as if it were a disk.  For example, you can copy a vxWorks
image from your host to TFFS by using file system 'copy'.  Of course, you must
define INCLUDE_DISK_UTIL in config.h first.

\cs
    copy("vxWorks.st", "/tffs0/vxWorks.st");
\ce

If you want to use "/tffs0" as a boot device, you should follow these steps:

For command line mode, make sure INCLUDE_TFFS is defined in config.h, re-build
a bootrom from the BSP directory under VxWorks Development Shell, and program
it into the flash chip.  Also make sure you have all the necessary file system
components defined in config.h.

For project mode with PROFILE_BOOTAPP profile under Workbench, you should make
sure to include the following components in the Kernel Configuration Window:

\cs
    INCLUDE_TFFS_MOUNT
    INCLUDE_ERF
    INCLUDE_DEVICE_MANAGER
    INCLUDE_FS_EVENT_UTIL
    INCLUDE_FS_MONITOR
    INCLUDE_XBD
    INCLUDE_XBD_BLK_DEV
    INCLUDE_XBD_TRANS
    INCLUDE_DOSFS
    INCLUDE_DOSFS_DIR_FIXED
    INCLUDE_DOSFS_DIR_VFAT
    INCLUDE_DOSFS_FAT
    INCLUDE_DOSFS_FMT
    INCLUDE_DOSFS_MAIN
    INCLUDE_DISK_UTIL
    INCLUDE_BOOT_FILESYSTEMS
\ce

Then right click the project, select "Build Options\Set Active Build Spec...",
check the "default_romCompress" box, you will see "vxWorks.bin(default_romCompress)"
item is listed in the project, right click it and select "Build Target", this
will generate a default_romCompress.bin in the project directory, program
it into the flash chip as a bootrom.

Below is an example by using /tffs as a boot device:

\cs
    boot device          : fs
    unit number          : 0
    processor number     : 0
    host name            : host
    file name            : /tffs0/vxWorks
    inet on ethernet (e) : 192.168.0.3:ffffff00
    host inet (h)        : 192.168.0.2
    gateway inet (g)     : 192.168.0.1
    user (u)             : target
    ftp password (pw)    : vxTarget
    flags (f)            : 0x0
\ce

\sh SATA Support

There are 2 SATA interfaces, which are connected to socket J13 and J14 on the
P5020/P3041DS board. To use the SATA interfaces, the macro DRV_STORAGE_FSLSATA must
be defined in config.h.

When using an SATA disk for the first time, you should format it as a FAT file
system by using
\cs
    dosFsVolFormat ("/ata0:1", 0x20, 0);    /@ FAT32 format @/
\ce
or
\cs
    dosFsVolFormat ("/ata0:1", 0x10, 0);    /@ FAT16 format @/
\ce

Now, you can use VxWorks I/O and file system commands to access the SATA card
device as if it were a disk.  For example, you can copy a vxWorks image from
your host to the SATA disk by using file system copy.

\cs
    copy ("vxWorks", "/ata0:1/vxWorks");
\ce
If you want to use SATA disk as a boot device, you should follow these steps:

For command line mode, make sure DRV_STORAGE_FSLSATA is defined in config.h, re-build
a bootrom from the BSP directory under VxWorks Development Shell, and program
it into the flash chip.  Also make sure you have all the necessary file system
components defined in config.h.

For project mode with PROFILE_BOOTAPP profile under Workbench, you should make
sure to include the following components in the Kernel Configuration Window:

\cs
    DRV_STORAGE_FSLSATA
    INCLUDE_ERF
    INCLUDE_DEVICE_MANAGER
    INCLUDE_FS_EVENT_UTIL
    INCLUDE_FS_MONITOR
    INCLUDE_XBD
    INCLUDE_XBD_BLK_DEV
    INCLUDE_XBD_TRANS
    INCLUDE_DOSFS
    INCLUDE_DOSFS_DIR_FIXED
    INCLUDE_DOSFS_DIR_VFAT
    INCLUDE_DOSFS_FAT
    INCLUDE_DOSFS_FMT
    INCLUDE_DOSFS_MAIN
    INCLUDE_DISK_UTIL
    INCLUDE_BOOT_FILESYSTEMS
\ce

Then right click the project, select "Build Options\Set Active Build Spec...",
check the "default_romCompress" box, you will see "vxWorks.bin(default_romCompress)"
item is listed in the project, right click it and select "Build Target", this
will generate a default_romCompress.bin in the project directory, program
it into the flash chip as a bootrom.

Below is an example by using /ata0:1 as a boot device:

\cs
    boot device          : fs
    unit number          : 0
    processor number     : 0
    host name            : host
    file name            : /ata0:1/vxWorks
    inet on ethernet (e) : 192.168.0.3:ffffff00
    host inet (h)        : 192.168.0.2
    gateway inet (g)     : 192.168.0.1
    user (u)             : target
    ftp password (pw)    : vxTarget
    flags (f)            : 0x0
\ce

Note: If CDROM want to be used, the component INCLUDE_CDROMFS must be configured 
into the system to obtain the VxWorks CD-ROM file system (cdromFs).

\sh Programmable Interrupt Controller

The PIC driver provided by this BSP supports all internal and external
interrupt sources. The driver can also be configured to route such interrupt
sources to the critical interrupt pin. However, because critical interrupts
are routed directly to the interrupt source instead of being manager by the
PIC with IACK or EOI, the Critical Interrupt Summary registers are used to
check for the source. The transient values in these registers cause a spurious
vector when indexing into the vector table.

\sh eSPI and SPI Flash
The Freescale eSPI Controller and Spansion SPI Flash S25FLXX are supported 
(only in polled mode) in this release.

To enable this function, please define the following macro in config.h:

\cs
    #define DRV_SPI_S25FLXX
\ce

\sh I2C

The P5020/P3041 processor has a total of 4 I2C controllers. Use of the I2C 
controllers requires the DRV_I2CBUS_FSL driver component, as well as 
INCLUDE_I2C_BUS, which is also required. Polling and interrupt have been 
integrated into the driver. This BSP defaults to use interrupts. 

The Maxim DS3232 RTC, Atmel EEPROM are supported in this release.

To use the DS3232 RTC device, which can use the routine sysRtcSet() that is a 
command-line utility for setting the RTC from the VxWorks kernel prompt. The 
user will be prompted for the appropriate input. To read the date and the time, 
the following routine sysRtcGet () have to be called.

To use the Atmel EEPROM device, the driver allows the I/O system to access EEPROM
directly as a I/O device.  EEPROM device and size are specified when the
device is created. All the created EEPROM will be seen when use the 'devs' 
command from the VxWorks shell.

Note: the four I2C controllers share two internal interrupt line, so every two 
controllers(0-1/2-3) must be assigned to the same core.

\sh Make Targets
The make targets are listed as the names of object-format files. Append `.hex'
to each to derive a hex-format file name. Other images not listed here may not
be tested.

\ts
`bootrom'
`bootrom.bin'
`vxWorks' (with `vxWorks.sym')
`vxWorks.st'
\te

\sh BSP Bootloaders and Bootroms

\ts
Bootloader/Bootrom   | status
----------------------------------
bootrom              | SUPPORTED
bootrom_uncmp        | SUPPORTED
bootrom_res          | UNSUPPORTED
vxWorks              | SUPPORTED
vxWorks_rom          | UNSUPPORTED
vxWorks_romCompress  | SUPPORTED
vxWorks_romResident  | UNSUPPORTED
\te

Note: The default size of the vxWorks_rom images are larger than the default 
ROM_SIZE of 1MB, so vxWorks_rom are not supported. However, it can be supported
by adjusted ROM_SIZE and the corresponding addresses in config.h and Makefile 
to fit these image.

\sh BSP Validated Tools

\ts
Tool                         | Connection/Type | Status
-------------------------------------------------------
Workbench Debugger           | ETHERNET/WDB    | UNVALIDATED
Workbench System Viewer      | ETHERNET/WDB    | UNVALIDATED
Workbench MemScope           | ETHERNET/WDB    | UNVALIDATED
Workbench ProfileScope       | ETHERNET/WDB    | UNVALIDATED
Workbench StethoScope        | ETHERNET/WDB    | UNVALIDATED
Workbench CoverageScope      | ETHERNET/WDB    | UNVALIDATED
Workbench Core File Analysis | ETHERNET/WDB    | UNVALIDATED
Workbench Sensor Points      | ETHERNET/WDB    | UNVALIDATED
Workbench OCD Debugger       | JTAG            | UNSUPPORTED
\te

\sh Known Issues

1. The SATA CRC error status report is not reliable and cannot be used by SW. 
In addition, fatal errors report by SATA drive after read commands greater 
than 8KB, require a soft reset to the SATA Host controller. The workaround 
enables functionality of the SATA controller, but performance is greatly reduced.
More information see errata SATA-A005 in P5020/P3041 Chip Errata (Rev.C).pdf.

BOARD LAYOUT

\bs
+------------------------------------------------------------------------------+
| | | | | | | | | | | | | | |  | USB1 |DTSEC4|  |UART0|   |SD-CARD|  |USB2|    | 
| |S| |S| |S| |S| |S| |S| |S|  +------+------+  +-----+   +-------+  +----+    |
| | | | | | | | | | | | | | |  |DTSEC3|         |UART1|                        |
| |L| |L| |L| |L| |L| |L| |L|  |RGMII |         |(top)|                        |
| | | | | | | | | | | | | | |  +------+         +-----+                        |
| |O| |O| |O| |O| |O| |O| |O|                                                  |
| | | | | | | | | | | | | | |  +-----++-----+                                  |
| |T| |T| |T| |T| |T| |T| |T|  |SATA1||SATA2|                    +--+  +--+    |
| | | | | | | | | | | | | | |  +-----++-----+                    | D|  | D|    |
| |1| |2| |3| |4| |5| |6| |7|                                    | D|  | D|    |
| | | | | | | | | | | | | | |                  +-----------+     | R|  | R|    |        
| +-+ +-+ +-+ +-+ +-+ +-+ +-+                  |           |     | 1|  | 2|    |
|   +----------+                               |   QorIQ   |     +--+  +--+    |
|   | LED-5020 |                               |           |                   |
|   +----------+                               |   P5020E  |                   |
|                                              |  (P3041E) |                   |
|  +---+ +---+ +---+                           +-----------+                   |
|  |SW1| |SW5| |SW9|                                                           |
|  +---+ +---+ +---+                                                           |
|  +---+ +---+ +----+                                                          |
|  |SW2| |SW6| |SW10|            +-+                                           |
|  +---+ +---+ +----+            |J|                +-----------+              |
|  +---+ +---+                   |T|                |NAND08GW3B2|              |
|  |SW3| |SW7|                   |A|                +-----------+              |
|  +---+ +---+                   |G|                                           |
|  +---+ +---+                   +-+                                           |
|  |SW4| |SW8|                            +-----------+                        |
|  +---+ +---+                            | NOR-FLASH |                        |
| +-------+                +----------+   +-----------+                        |
| | POWER |                |RTC-DS3232|                                        |
| +-------+                +----------+                                        |
+------------------------------------------------------------------------------+
\be

BIBLIOGRAPHY
For further information on the fsl_p5020_ds/fsl_p3041_ds, refer to the following
documents:

\tb P3041/P5020 DS HW Specification

\tb P3041/5020 DS Development System board schematics

\tb P3041/P5020 Hardware Getting Started Guide

\tb P3041/P5020 QorIQ Integrated Multicore Communication Processor Family Reference Manual

\tb e5500 Core Reference Manual

\tb e500mc Core Reference Manual

\tb Wind River Simics P50x0 REFERENCE MANUAL 4.4

SEE ALSO

\tb Workbench User's Guide: Introduction

\tb VxWorks Programmer's Guide: Configuration

\tb VxWorks Programmer's Guide: Architecture Appendix

